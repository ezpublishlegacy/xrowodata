Index: Index.php
===================================================================
--- Index.php	(revision 2307)
+++ Index.php	(working copy)
@@ -14,7 +14,7 @@
  * @link      http://odataphpproducer.codeplex.com
  * 
  */
-require_once dirname(__FILE__).DIRECTORY_SEPARATOR.'library'.DIRECTORY_SEPARATOR.'ODataProducer'.DIRECTORY_SEPARATOR.'Common'.DIRECTORY_SEPARATOR.'ClassAutoLoader.php';
+require_once dirname(__FILE__).'/library/ODataProducer/Common/ClassAutoLoader.php';
 require_once 'Dispatcher.php';
 use ODataProducer\Common\ClassAutoLoader;
 ClassAutoLoader::register();
Index: library/ODataProducer/ObjectModel/ObjectModelSerializer.php
===================================================================
--- library/ODataProducer/ObjectModel/ObjectModelSerializer.php	(revision 2307)
+++ library/ODataProducer/ObjectModel/ObjectModelSerializer.php	(working copy)
@@ -1,4 +1,4 @@
-<?php
+<?php
 /** 
  * The object model serializer.
  * 
@@ -12,27 +12,24 @@
  * @version   SVN: 1.0
  * @link      http://odataphpproducer.codeplex.com
  * 
- */
-namespace ODataProducer\ObjectModel;
-use ODataProducer\Common\ODataConstants;
-use ODataProducer\Common\InvalidOperationException;
-use ODataProducer\UriProcessor\RequestCountOption;
-use ODataProducer\UriProcessor\ResourcePathProcessor\SegmentParser\RequestTargetSource;
-use ODataProducer\UriProcessor\RequestDescription;
-use ODataProducer\DataService;
-use ODataProducer\Providers\Metadata\ResourceType;
-use ODataProducer\Providers\Metadata\ResourceTypeKind;
-use ODataProducer\Providers\Metadata\ResourcePropertyKind;
-use ODataProducer\Providers\Metadata\ResourceProperty;
-use ODataProducer\Providers\MetadataQueryProviderWrapper;
-use ODataProducer\Providers\Metadata\Type\Binary;
-use ODataProducer\Providers\Metadata\Type\Boolean;
-use ODataProducer\Providers\Metadata\Type\String;
-use ODataProducer\Common\ODataException;
-use ODataProducer\Common\Messages;
-use xrowObject2XML;
-use DOMDocument;
-
+ */
+namespace ODataProducer\ObjectModel;
+use ODataProducer\Common\ODataConstants;
+use ODataProducer\Common\InvalidOperationException;
+use ODataProducer\UriProcessor\RequestCountOption;
+use ODataProducer\UriProcessor\ResourcePathProcessor\SegmentParser\RequestTargetSource;
+use ODataProducer\UriProcessor\RequestDescription;
+use ODataProducer\DataService;
+use ODataProducer\Providers\Metadata\ResourceType;
+use ODataProducer\Providers\Metadata\ResourceTypeKind;
+use ODataProducer\Providers\Metadata\ResourcePropertyKind;
+use ODataProducer\Providers\Metadata\ResourceProperty;
+use ODataProducer\Providers\MetadataQueryProviderWrapper;
+use ODataProducer\Providers\Metadata\Type\Binary;
+use ODataProducer\Providers\Metadata\Type\Boolean;
+use ODataProducer\Providers\Metadata\Type\String;
+use ODataProducer\Common\ODataException;
+use ODataProducer\Common\Messages;
 /**
  * The object model serializer.
  * 
@@ -43,116 +40,132 @@
  * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
  * @version   Release: 1.0
  * @link      http://odataphpproducer.codeplex.com
- */
-class ObjectModelSerializer extends ObjectModelSerializerBase
-{
-
+ */
+class ObjectModelSerializer extends ObjectModelSerializerBase
+{
     /**
      * Creates new instance of ObjectModelSerializer.
      * 
      * @param DataService        &$dataService        Reference to data service 
-     * instance.
+     *                                                instance.
      * @param RequestDescription &$requestDescription Reference to the 
-     * type describing
-     * request submitted by the 
-     * client. 
-     */
-    public function __construct( DataService &$dataService, RequestDescription &$requestDescription )
-    {
-        parent::__construct( $dataService, $requestDescription );
-    }
-
+     *                                                type describing
+     *                                                request submitted by the 
+     *                                                client. 
+     */
+    public function __construct(DataService &$dataService, RequestDescription &$requestDescription)
+    {
+        parent::__construct($dataService, $requestDescription);
+    }
+
     /**
      * Write a top level entry resource.
      * 
      * @param mixed &$entryObject Reference to the entry object to be written.
      * 
      * @return ODataEntry
-     */
-    public function writeTopLevelElement( &$entryObject )
-    {
-        $requestTargetSource = $this->requestDescription->getTargetSource();
-        $odataEntry = new ODataEntry();
-        $odataEntry->isTopLevel = true;
-        $resourceType = null;
-        if ( $requestTargetSource == RequestTargetSource::ENTITY_SET )
-        {
-            $resourceType = $this->requestDescription->getTargetResourceType();
-        }
-        else
-        {
-            $this->assert( $requestTargetSource == RequestTargetSource::PROPERTY, '$requestTargetSource == RequestTargetSource::PROPERTY' );
-            $resourceProperty = $this->requestDescription->getProjectedProperty();
+     */
+    public function writeTopLevelElement(&$entryObject)
+    {
+        $requestTargetSource = $this->requestDescription->getTargetSource();
+        $odataEntry = new ODataEntry();
+        $odataEntry->isTopLevel = true;
+        $resourceType = null;
+        if ($requestTargetSource == RequestTargetSource::ENTITY_SET) {
+            $resourceType = $this->requestDescription->getTargetResourceType();
+        } else {
+            $this->assert(
+                $requestTargetSource == RequestTargetSource::PROPERTY, 
+                '$requestTargetSource == RequestTargetSource::PROPERTY'
+            );
+            $resourceProperty = $this->requestDescription->getProjectedProperty();
             //$this->assert($resourceProperty->getKind() == ResourcePropertyKind::RESOURCE_REFERENCE, '$resourceProperty->getKind() == ResourcePropertyKind::RESOURCE_REFERENCE');
-            $resourceType = $resourceProperty->getResourceType();
-        }
-        
-        $needPop = $this->pushSegmentForRoot();
-        $this->_writeEntryElement( $entryObject, $resourceType, $this->requestDescription->getRequestUri()->getUrlAsString(), $this->requestDescription->getContainerName(), $odataEntry );
-        $this->popSegment( $needPop );
-        return $odataEntry;
-    }
-
+            $resourceType = $resourceProperty->getResourceType();
+        }
+
+        $needPop = $this->pushSegmentForRoot();
+        $this->_writeEntryElement(
+            $entryObject, $resourceType, 
+            $this->requestDescription->getRequestUri()->getUrlAsString(), 
+            $this->requestDescription->getContainerName(), $odataEntry
+        );
+        $this->popSegment($needPop);
+        return $odataEntry;        
+    }
+
     /**
      * Write top level feed element.
      * 
      * @param array(mixed) &$entryObjects Array of entry resources to be written.
      * 
      * @return ODataFeed.
-     */
-    public function writeTopLevelElements( &$entryObjects )
-    {
-        $this->assert( is_array( $entryObjects ), 'is_array($entryObjects)' );
-        $requestTargetSource = $this->requestDescription->getTargetSource();
-        $title = null;
-        if ( $requestTargetSource == RequestTargetSource::ENTITY_SET )
-        {
-            $title = $this->requestDescription->getContainerName();
-        }
-        else
-        {
-            $this->assert( $requestTargetSource == RequestTargetSource::PROPERTY, '$requestTargetSource == RequestTargetSource::PROPERTY' );
-            $resourceProperty = $this->requestDescription->getProjectedProperty();
-            $this->assert( $resourceProperty->getKind() == ResourcePropertyKind::RESOURCESET_REFERENCE, '$resourceProperty->getKind() == ResourcePropertyKind::RESOURCESET_REFERENCE' );
-            $title = $resourceProperty->getName();
-        }
-        
-        $relativeUri = $this->requestDescription->getIdentifier();
-        $odataFeed = new ODataFeed();
-        $odataFeed->isTopLevel = true;
-        if ( $this->requestDescription->getRequestCountOption() == RequestCountOption::INLINE )
-        {
-            $odataFeed->rowCount = $this->requestDescription->getCountValue();
-        }
-        
-        $needPop = $this->pushSegmentForRoot();
-        $targetResourceType = $this->requestDescription->getTargetResourceType();
-        $this->_writeFeedElements( $entryObjects, $targetResourceType, $title, $this->requestDescription->getRequestUri()->getUrlAsString(), $relativeUri, $odataFeed );
-        $this->popSegment( $needPop );
-        return $odataFeed;
-    }
-
+     */
+    public function writeTopLevelElements(&$entryObjects)
+    {
+        $this->assert(is_array($entryObjects), 'is_array($entryObjects)');
+        $requestTargetSource = $this->requestDescription->getTargetSource();
+        $title = null;
+        if ($requestTargetSource == RequestTargetSource::ENTITY_SET) {
+            $title = $this->requestDescription->getContainerName();
+        } else {
+            $this->assert(
+                $requestTargetSource == RequestTargetSource::PROPERTY, 
+                '$requestTargetSource == RequestTargetSource::PROPERTY'
+            );            
+            $resourceProperty = $this->requestDescription->getProjectedProperty();
+            $this->assert(
+                $resourceProperty->getKind() == ResourcePropertyKind::RESOURCESET_REFERENCE, 
+                '$resourceProperty->getKind() == ResourcePropertyKind::RESOURCESET_REFERENCE'
+            );
+            $title = $resourceProperty->getName();
+        }
+
+        $relativeUri = $this->requestDescription->getIdentifier(); 
+        $odataFeed = new ODataFeed();
+        $odataFeed->isTopLevel = true;
+        if ($this->requestDescription->getRequestCountOption() == RequestCountOption::INLINE) {
+            $odataFeed->rowCount = $this->requestDescription->getCountValue();
+        }
+
+        $needPop = $this->pushSegmentForRoot();
+        $targetResourceType = $this->requestDescription->getTargetResourceType();
+        $this->_writeFeedElements(
+            $entryObjects,
+            $targetResourceType,
+            $title,
+            $this->requestDescription->getRequestUri()->getUrlAsString(),
+            $relativeUri,
+            $odataFeed
+        );
+        $this->popSegment($needPop);
+        return $odataFeed;
+    }
+
     /**
      * Write top level url element.
      * 
      * @param mixed &$entryObject The entry resource whose url to be written.
      * 
      * @return ODataRL
-     */
-    public function writeUrlElement( &$entryObject )
-    {
-        $odataUrl = new ODataURL();
-        if ( ! is_null( $entryObject ) )
-        {
-            $currentResourceType = $this->getCurrentResourceSetWrapper()->getResourceType();
-            $relativeUri = $this->getEntryInstanceKey( $entryObject, $currentResourceType, $this->getCurrentResourceSetWrapper()->getName() );
-            
-            $odataUrl->oDataUrl = rtrim( $this->absoluteServiceUri, '/' ) . '/' . $relativeUri;
-        }
-        
-        return $odataUrl;
-    }
-
+     */
+    public function writeUrlElement(&$entryObject)
+    {
+        $odataUrl = new ODataURL();
+        if (!is_null($entryObject)) {
+            $currentResourceType = $this->getCurrentResourceSetWrapper()->getResourceType();
+            $relativeUri = $this->getEntryInstanceKey(
+                $entryObject, 
+                $currentResourceType,
+                $this->getCurrentResourceSetWrapper()->getName()
+            );
+            
+            $odataUrl->oDataUrl 
+                = rtrim($this->absoluteServiceUri, '/') . '/' . $relativeUri;
+        }
+
+        return $odataUrl;
+    }
+
     /**
      * Write top level url collection.
      * 
@@ -160,99 +173,112 @@
      * whose url to be written.
      * 
      * @return ODataURLCollection
-     */
-    public function writeUrlElements( &$entryObjects )
-    {
-        $odataUrlCollection = new ODataURLCollection();
-        if ( ! empty( $entryObjects ) )
-        {
-            $i = 0;
-            foreach ( $entryObjects as &$entryObject )
-            {
-                $odataUrlCollection->oDataUrls[$i] = $this->writeUrlElement( $entryObject );
-                $i ++;
-            }
-            
-            if ( $i > 0 && $this->needNextPageLink( count( $entryObjects ) ) )
-            {
-                $odataUrlCollection->nextPageLink = $this->getNextLinkUri( $entryObjects[$i - 1], $this->requestDescription->getRequestUri()->getUrlAsString() );
-            }
-        }
-        
-        if ( $this->requestDescription->getRequestCountOption() == RequestCountOption::INLINE )
-        {
-            $odataUrlCollection->count = $this->requestDescription->getCountValue();
-        }
-        
-        return $odataUrlCollection;
-    }
-
+     */
+    public function writeUrlElements(&$entryObjects)
+    {
+        $odataUrlCollection = new ODataURLCollection();
+        if (!empty($entryObjects)) {        
+            $i = 0;
+            foreach ($entryObjects as &$entryObject) {
+                $odataUrlCollection->oDataUrls[$i] = $this->writeUrlElement($entryObject);
+                $i++;
+            }
+
+            if ($i > 0 && $this->needNextPageLink(count($entryObjects))) {
+                $odataUrlCollection->nextPageLink = $this->getNextLinkUri($entryObjects[$i - 1], $this->requestDescription->getRequestUri()->getUrlAsString());
+            }
+        }
+
+        if ($this->requestDescription->getRequestCountOption() == RequestCountOption::INLINE) {
+            $odataUrlCollection->count = $this->requestDescription->getCountValue();
+        }
+
+        return $odataUrlCollection;
+    }
+
     /**
      * Write top level complex resource.
      * 
      * @param mixed                &$complexValue         The complex object to be 
-     * written.
+     *                                                    written.
      * @param string               $propertyName          The name of the 
-     * complex property.
+     *                                                    complex property.
      * @param ResourceType         &$resourceType         Describes the type of 
-     * complex object.
+     *                                                    complex object.
      * @param ODataPropertyContent &$odataPropertyContent On return, this object
-     * will hold complex value
-     * which can be used by writer
+     *                                                    will hold complex value
+     *                                                    which can be used by writer
      *
      * @return void
-     */
-    public function writeTopLevelComplexObject( &$complexValue, $propertyName, ResourceType &$resourceType, ODataPropertyContent &$odataPropertyContent )
-    {
-        $odataPropertyContent->isTopLevel = true;
-        $this->_writeComplexValue( $complexValue, $propertyName, $resourceType, null, $odataPropertyContent );
-    }
-
+     */
+    public function writeTopLevelComplexObject(&$complexValue,
+        $propertyName, ResourceType &$resourceType,
+        ODataPropertyContent &$odataPropertyContent
+    ) {
+        $odataPropertyContent->isTopLevel = true;
+        $this->_writeComplexValue(
+            $complexValue,
+            $propertyName, $resourceType, null, 
+            $odataPropertyContent
+        );
+    }
+
     /**
      * Write top level bag resource.
      * 
      * @param mixed                &$BagValue             The bag object to be 
-     * written.
+     *                                                    written.
      * @param string               $propertyName          The name of the 
-     * bag property.
+     *                                                    bag property.
      * @param ResourceType         &$resourceType         Describes the type of 
-     * bag object.
+     *                                                    bag object.
      * @param ODataPropertyContent &$odataPropertyContent On return, this object 
-     * will hold bag value which
-     * can be used by writers.
+     *                                                    will hold bag value which
+     *                                                    can be used by writers.
      * 
      * @return void
-     */
-    public function writeTopLevelBagObject( &$BagValue, $propertyName, ResourceType &$resourceType, ODataPropertyContent &$odataPropertyContent )
-    {
-        $odataPropertyContent->isTopLevel = true;
-        $this->_writeBagValue( $BagValue, $propertyName, $resourceType, null, $odataPropertyContent );
-    }
-
+     */
+    public function writeTopLevelBagObject(&$BagValue,
+        $propertyName, ResourceType &$resourceType,
+        ODataPropertyContent &$odataPropertyContent 
+    ) {
+        $odataPropertyContent->isTopLevel = true;
+        $this->_writeBagValue(
+            $BagValue,
+            $propertyName, $resourceType, null,
+            $odataPropertyContent
+        );
+    }
+
     /**
      * Write top level primitive value.
      * 
      * @param mixed                &$primitiveValue       The primitve value to be 
-     * written.
+     *                                                    written.
      * @param ResourceProperty     &$resourceProperty     Resource property 
-     * describing the 
-     * primitive property 
-     * to be written. 
+     *                                                    describing the 
+     *                                                    primitive property 
+     *                                                    to be written. 
      * @param ODataPropertyContent &$odataPropertyContent On return, this object 
-     * will hold
-     * primitive value 
-     * which can be used 
-     * by writers.
+     *                                                    will hold
+     *                                                    primitive value 
+     *                                                    which can be used 
+     *                                                    by writers.
      * 
      * @return void
-     */
-    public function writeTopLevelPrimitive( &$primitiveValue, ResourceProperty &$resourceProperty, ODataPropertyContent &$odataPropertyContent )
-    {
-        $odataPropertyContent->isTopLevel = true;
-        $odataPropertyContent->odataProperty[] = new ODataProperty();
-        $this->_writePrimitiveValue( $primitiveValue, $resourceProperty, $odataPropertyContent->odataProperty[0] );
-    }
-
+     */
+    public function writeTopLevelPrimitive(&$primitiveValue, 
+        ResourceProperty &$resourceProperty, ODataPropertyContent &$odataPropertyContent
+    ) {
+        $odataPropertyContent->isTopLevel = true;
+        $odataPropertyContent->odataProperty[] = new ODataProperty();
+        $this->_writePrimitiveValue(
+            $primitiveValue, 
+            $resourceProperty, 
+            $odataPropertyContent->odataProperty[0]
+        );
+    }
+
     /**
      * Write an entry element.
      * 
@@ -263,592 +289,620 @@
      * @param ODataEntry   &$odataEntry   OData entry object to write to.
      * 
      * @return void
-     */
-    private function _writeEntryElement( &$entryObject, ResourceType &$resourceType, $absoluteUri, $relativeUri, ODataEntry &$odataEntry )
-    {
-        if ( is_null( $entryObject ) )
-        {
+     */
+    private function _writeEntryElement(&$entryObject, 
+        ResourceType &$resourceType,
+        $absoluteUri, $relativeUri, ODataEntry &$odataEntry
+    ) {
+        if (is_null($entryObject)) {
             //According to atom standard an empty entry must have an Author
-        //node.
-        }
-        else
-        {
-            $relativeUri = $this->getEntryInstanceKey( $entryObject, $resourceType, $this->getCurrentResourceSetWrapper()->getName() );
-            
-            $absoluteUri = rtrim( $this->absoluteServiceUri, '/' ) . '/' . $relativeUri;
-            $title = $resourceType->getName();
+            //node.
+        } else {
+            $relativeUri = $this->getEntryInstanceKey(
+                $entryObject, 
+                $resourceType,
+                $this->getCurrentResourceSetWrapper()->getName()
+            );
+
+            $absoluteUri = rtrim($this->absoluteServiceUri, '/') . '/' . $relativeUri;
+            $title = $resourceType->getName();
             //TODO Resolve actual resource type
-            $actualResourceType = $resourceType;
-            $this->_writeMediaResourceMetadata( $entryObject, $actualResourceType, $title, $relativeUri, $odataEntry );
-            
-            $odataEntry->id = $absoluteUri;
-            $odataEntry->eTag = $this->getETagForEntry( $entryObject, $resourceType );
-            $odataEntry->title = $title;
-            $odataEntry->editLink = $relativeUri;
-            $odataEntry->type = $actualResourceType->getFullName();
-            $odataPropertyContent = new ODataPropertyContent();
-            $this->_writeObjectProperties( $entryObject, $actualResourceType, $absoluteUri, $relativeUri, $odataEntry, $odataPropertyContent );
-            $odataEntry->propertyContent = $odataPropertyContent;
-        }
-    }
-
+            $actualResourceType = $resourceType;
+            $this->_writeMediaResourceMetadata(
+                $entryObject,
+                $actualResourceType,
+                $title,
+                $relativeUri,
+                $odataEntry
+            );
+
+            $odataEntry->id = $absoluteUri;
+            $odataEntry->eTag = $this->getETagForEntry($entryObject, $resourceType);
+            $odataEntry->title = $title;
+            $odataEntry->editLink = $relativeUri;
+            $odataEntry->type = $actualResourceType->getFullName();
+            $odataPropertyContent = new ODataPropertyContent();
+            $this->_writeObjectProperties(
+                $entryObject, 
+                $actualResourceType,
+                $absoluteUri,
+                $relativeUri,
+                $odataEntry,
+                $odataPropertyContent
+            );
+            $odataEntry->propertyContent = $odataPropertyContent;
+        }
+    }
+
     /**
      * Writes the feed elements
      * 
      * @param array        &$entryObjects Array of entries in the feed element.
      * @param ResourceType &$resourceType The resource type of the f the elements 
-     * in the collection.
+     *                                    in the collection.
      * @param string       $title         Title of the feed element.
      * @param string       $absoluteUri   Absolute uri representing the feed element.
      * @param string       $relativeUri   Relative uri representing the feed element.
      * @param ODataFeed    &$odataFeed    Feed to write to.
      * 
      * @return void
-     */
-    private function _writeFeedElements( &$entryObjects, ResourceType &$resourceType, $title, $absoluteUri, $relativeUri, ODataFeed &$odataFeed )
-    {
-        $this->assert( is_array( $entryObjects ), '_writeFeedElements::is_array($entryObjects)' );
-        $odataFeed->id = $absoluteUri;
-        $odataFeed->title = $title;
-        $odataFeed->selfLink = new ODataLink();
-        $odataFeed->selfLink->name = ODataConstants::ATOM_SELF_RELATION_ATTRIBUTE_VALUE;
-        $odataFeed->selfLink->title = $title;
-        $odataFeed->selfLink->url = $relativeUri;
-        
-        if ( empty( $entryObjects ) )
-        {
+     */
+    private function _writeFeedElements(&$entryObjects, 
+        ResourceType &$resourceType, $title, 
+        $absoluteUri, $relativeUri, ODataFeed &$odataFeed
+    ) {
+        $this->assert(is_array($entryObjects), '_writeFeedElements::is_array($entryObjects)');
+        $odataFeed->id = $absoluteUri;
+        $odataFeed->title = $title;
+        $odataFeed->selfLink = new ODataLink();
+        $odataFeed->selfLink->name = ODataConstants::ATOM_SELF_RELATION_ATTRIBUTE_VALUE;
+        $odataFeed->selfLink->title =  $title;
+        $odataFeed->selfLink->url = $relativeUri;
+        
+        if (empty($entryObjects)) {
             //TODO // ATOM specification: if a feed contains no entries, 
-        //then the feed should 
-        //have at least one Author tag
-        }
-        else
-        {
-            $i = 0;
-            foreach ( $entryObjects as &$entryObject )
-            {
-                $odataFeed->entries[$i] = new ODataEntry();
-                $this->_writeEntryElement( $entryObject, $resourceType, null, null, $odataFeed->entries[$i] );
-                $i ++;
-            }
-            
-            if ( $this->needNextPageLink( count( $entryObjects ) ) )
-            {
-                $odataFeed->nextPageLink = $this->getNextLinkUri( $entryObjects[$i - 1], $absoluteUri );
-            }
-        }
-    }
-
+            //then the feed should 
+            //have at least one Author tag
+        } else {
+            $i = 0;
+            foreach ($entryObjects as &$entryObject) {
+                $odataFeed->entries[$i] = new ODataEntry();
+                $this->_writeEntryElement($entryObject, $resourceType, null, null, $odataFeed->entries[$i]);
+                $i++;
+            }
+
+            if ($this->needNextPageLink(count($entryObjects))) {
+                $odataFeed->nextPageLink = $this->getNextLinkUri($entryObjects[$i - 1], $absoluteUri);
+            }
+        }
+    }
+
     /**
      * Write values of properties of given entry (resource) or complex object.
      * 
      * @param mixed                $customObject          Entity or complex object 
-     * with properties  
-     * to write out.
+     *                                                    with properties  
+     *                                                    to write out.
      * @param ResourceType         &$resourceType         Resource type describing 
-     * the metadata of 
-     * the custom object.
+     *                                                    the metadata of 
+     *                                                    the custom object.
      * @param string               $absoluteUri           Absolute uri for the given 
-     * entry object 
-     * NULL for complex object.
+     *                                                    entry object 
+     *                                                    NULL for complex object.
      * @param string               $relativeUri           Relative uri for the given 
-     * custom object.
+     *                                                    custom object.
      * @param ODataEntry           &$odataEntry           ODataEntry instance to 
-     * place links and
-     * expansion of the 
-     * entry object, 
-     * NULL for complex object.
+     *                                                    place links and
+     *                                                    expansion of the 
+     *                                                    entry object, 
+     *                                                    NULL for complex object.
      * @param ODataPropertyContent &$odataPropertyContent ODataPropertyContent
-     * instance in which
-     * to place the values.
+     *                                                    instance in which
+     *                                                    to place the values.
      * 
      * @return void
-     */
-    private function _writeObjectProperties( $customObject, ResourceType &$resourceType, $absoluteUri, $relativeUri, &$odataEntry, ODataPropertyContent &$odataPropertyContent )
-    {
-        $resourceTypeKind = $resourceType->getResourceTypeKind();
-        if ( is_null( $absoluteUri ) == ( $resourceTypeKind == ResourceTypeKind::ENTITY ) )
-        {
-            ODataException::createInternalServerError( Messages::badProviderInconsistentEntityOrComplexTypeUsage( $resourceType->getName() ) );
-        }
-        
-        $this->assert( ( ( $resourceTypeKind == ResourceTypeKind::ENTITY ) && ( $odataEntry instanceof ODataEntry ) ) || ( ( $resourceTypeKind == ResourceTypeKind::COMPLEX ) && is_null( $odataEntry ) ), '(($resourceTypeKind == ResourceTypeKind::ENTITY) && ($odataEntry instanceof ODataEntry)) 
-            || (($resourceTypeKind == ResourceTypeKind::COMPLEX) && is_null($odataEntry))' );
-        $projectionNodes = null;
-        $navigationProperties = null;
-        if ( $resourceTypeKind == ResourceTypeKind::ENTITY )
-        {
-            $projectionNodes = $this->getProjectionNodes();
-            $navigationProperties = array();
-        }
-        
-        if ( is_null( $projectionNodes ) )
-        {
+     */
+    private function _writeObjectProperties($customObject, 
+        ResourceType &$resourceType, 
+        $absoluteUri, 
+        $relativeUri, 
+        &$odataEntry, 
+        ODataPropertyContent &$odataPropertyContent
+    ) {
+        $resourceTypeKind = $resourceType->getResourceTypeKind();
+        if (is_null($absoluteUri) == ($resourceTypeKind == ResourceTypeKind::ENTITY)
+        ) {
+            ODataException::createInternalServerError(
+                Messages::badProviderInconsistentEntityOrComplexTypeUsage(
+                    $resourceType->getName()
+                )
+            );
+        }
+
+        $this->assert(
+            (($resourceTypeKind == ResourceTypeKind::ENTITY) && ($odataEntry instanceof ODataEntry)) 
+            || (($resourceTypeKind == ResourceTypeKind::COMPLEX) && is_null($odataEntry)), 
+            '(($resourceTypeKind == ResourceTypeKind::ENTITY) && ($odataEntry instanceof ODataEntry)) 
+            || (($resourceTypeKind == ResourceTypeKind::COMPLEX) && is_null($odataEntry))'
+        );
+        $projectionNodes = null;
+        $navigationProperties = null;
+        if ($resourceTypeKind == ResourceTypeKind::ENTITY) {
+            $projectionNodes = $this->getProjectionNodes();
+            $navigationProperties = array();
+        }
+
+        if (is_null($projectionNodes)) {
             //This is the code path to handle properties of Complex type 
             //or Entry without projection (i.e. no expansion or selection)          
-            $resourceProperties = array();
-            if ( $resourceTypeKind == ResourceTypeKind::ENTITY )
-            {
+            $resourceProperties = array(); 
+            if ($resourceTypeKind == ResourceTypeKind::ENTITY) {
                 // If custom object is an entry then it can contain navigation 
                 // properties which are invisible (because the corrosponding 
                 // resource set is invisible).  
                 // IDSMP::getResourceProperties will give collection of properties
                 // which are visible.
-                $currentResourceSetWrapper1 = $this->getCurrentResourceSetWrapper();
-                $resourceProperties = $this->dataService->getMetadataQueryProviderWrapper()->getResourceProperties( $currentResourceSetWrapper1, $resourceType );
-            }
-            else
-            {
-                $resourceProperties = $resourceType->getAllProperties();
-            }
-            
+                $currentResourceSetWrapper1 = $this->getCurrentResourceSetWrapper();
+                $resourceProperties = $this->dataService
+                    ->getMetadataQueryProviderWrapper()
+                    ->getResourceProperties(
+                        $currentResourceSetWrapper1, 
+                        $resourceType
+                    );
+            } else {
+                $resourceProperties = $resourceType->getAllProperties();
+            }
+
             //First write out primitve types
-            foreach ( $resourceProperties as $name => $resourceProperty )
-            {
-                if ( $resourceProperty->getKind() == ResourcePropertyKind::PRIMITIVE || $resourceProperty->getKind() == ( ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY ) || $resourceProperty->getKind() == ( ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::ETAG ) || $resourceProperty->getKind() == ( ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY | ResourcePropertyKind::ETAG ) )
-                {
-                    $odataProperty = new ODataProperty();
-                    $primitiveValue = $this->getPropertyValue( $customObject, $resourceType, $resourceProperty );
-                    $this->_writePrimitiveValue( $primitiveValue, $resourceProperty, $odataProperty );
-                    $odataPropertyContent->odataProperty[] = $odataProperty;
-                }
-            }
-            
+            foreach ($resourceProperties as $name => $resourceProperty) {
+                if ($resourceProperty->getKind() == ResourcePropertyKind::PRIMITIVE 
+                    || $resourceProperty->getKind() == (ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY) 
+                    || $resourceProperty->getKind() == (ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::ETAG)
+                    || $resourceProperty->getKind() == (ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY | ResourcePropertyKind::ETAG)
+                ) {
+                    $odataProperty = new ODataProperty();
+                    $primitiveValue = $this->getPropertyValue($customObject, $resourceType, $resourceProperty);
+                    $this->_writePrimitiveValue($primitiveValue, $resourceProperty, $odataProperty);
+                    $odataPropertyContent->odataProperty[] = $odataProperty;
+                }
+            }
+
             //Write out bag and complex type
-            $i = 0;
-            foreach ( $resourceProperties as $resourceProperty )
-            {
-                if ( $resourceProperty->isKindOf( ResourcePropertyKind::BAG ) )
-                {
+            $i = 0;
+            foreach ($resourceProperties as $resourceProperty) {                
+                if ($resourceProperty->isKindOf(ResourcePropertyKind::BAG)) {
                     //Handle Bag Property (Bag of Primitive or complex)
-                    $propertyValue = $this->getPropertyValue( $customObject, $resourceType, $resourceProperty );
-                    $resourceType2 = $resourceProperty->getResourceType();
-                    $this->_writeBagValue( $propertyValue, $resourceProperty->getName(), $resourceType2, $relativeUri . '/' . $resourceProperty->getName(), $odataPropertyContent );
-                }
-                else
-                {
-                    $resourcePropertyKind = $resourceProperty->getKind();
-                    if ( $resourcePropertyKind == ResourcePropertyKind::COMPLEX_TYPE )
-                    {
-                        
-                        $propertyValue = $this->getPropertyValue( $customObject, $resourceType, $resourceProperty );
-                        $resourceType1 = $resourceProperty->getResourceType();
-                        $this->_writeComplexValue( $propertyValue, $resourceProperty->getName(), $resourceType1, $relativeUri . '/' . $resourceProperty->getName(), $odataPropertyContent );
-                    }
-                    else 
-                        if ( $resourceProperty->getKind() == ResourcePropertyKind::PRIMITIVE || $resourceProperty->getKind() == ( ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY ) || $resourceProperty->getKind() == ( ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::ETAG ) || $resourceProperty->getKind() == ( ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY | ResourcePropertyKind::ETAG ) )
-                        {
-                            continue;
-                        }
-                        else
-                        {
-                            $this->assert( ( $resourcePropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE ) || ( $resourcePropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE ), '($resourcePropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE)
-                             || ($resourcePropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE)' );
-                            
-                            $navigationProperties[$i] = new NavigationPropertyInfo( $resourceProperty, $this->shouldExpandSegment( $resourceProperty->getName() ) );
-                            if ( $navigationProperties[$i]->expanded )
-                            {
-                                $navigationProperties[$i]->value = $this->getPropertyValue( $customObject, $resourceType, $resourceProperty );
-                            }
-                            
-                            $i ++;
-                        }
-                }
-            }
-        
-        }
-        else
-        { //This is the code path to handle projected properties of Entry
-            $i = 0;
-            foreach ( $projectionNodes as $projectionNode )
-            {
-                $propertyName = $projectionNode->getPropertyName();
-                $resourceProperty = $resourceType->tryResolvePropertyTypeByName( $propertyName );
-                $this->assert( ! is_null( $resourceProperty ), '!is_null($resourceProperty)' );
-                
-                if ( $resourceProperty->getTypeKind() == ResourceTypeKind::ENTITY )
-                {
-                    $currentResourceSetWrapper2 = $this->getCurrentResourceSetWrapper();
-                    $resourceProperties = $this->dataService->getMetadataQueryProviderWrapper()->getResourceProperties( $currentResourceSetWrapper2, $resourceType );
+                    $propertyValue = $this->getPropertyValue($customObject, $resourceType, $resourceProperty);
+                    $resourceType2 = $resourceProperty->getResourceType();
+                    $this->_writeBagValue(
+                        $propertyValue,
+                        $resourceProperty->getName(),
+                        $resourceType2,
+                        $relativeUri . '/' . $resourceProperty->getName(),
+                        $odataPropertyContent
+                    );
+                } else {
+                    $resourcePropertyKind = $resourceProperty->getKind();
+                    if ($resourcePropertyKind == ResourcePropertyKind::COMPLEX_TYPE) {
+                        $propertyValue = $this->getPropertyValue($customObject, $resourceType, $resourceProperty);
+                        $resourceType1 = $resourceProperty->getResourceType();
+                        $this->_writeComplexValue(
+                            $propertyValue,
+                            $resourceProperty->getName(),
+                            $resourceType1,
+                            $relativeUri . '/' . $resourceProperty->getName(),
+                            $odataPropertyContent
+                        );
+                    } else if ($resourceProperty->getKind() == ResourcePropertyKind::PRIMITIVE 
+                        || $resourceProperty->getKind() == (ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY) 
+                        || $resourceProperty->getKind() == (ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::ETAG)
+                        || $resourceProperty->getKind() == (ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY | ResourcePropertyKind::ETAG)
+                    ) {
+                        continue;  
+                    } else {
+                         $this->assert(
+                             ($resourcePropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE)
+                             || ($resourcePropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE), 
+                             '($resourcePropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE)
+                             || ($resourcePropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE)'
+                         );
+
+                        $navigationProperties[$i] = new NavigationPropertyInfo($resourceProperty, $this->shouldExpandSegment($resourceProperty->getName()));
+                        if ($navigationProperties[$i]->expanded) {
+                            $navigationProperties[$i]->value = $this->getPropertyValue($customObject, $resourceType, $resourceProperty);
+                        }
+
+                        $i++;                        
+                    }
+                }
+            }
+                
+        } else { //This is the code path to handle projected properties of Entry
+            $i = 0;
+            foreach ($projectionNodes as $projectionNode) {
+                $propertyName = $projectionNode->getPropertyName();
+                $resourceProperty = $resourceType->tryResolvePropertyTypeByName($propertyName);
+                $this->assert(!is_null($resourceProperty), '!is_null($resourceProperty)');
+                
+                if ($resourceProperty->getTypeKind() == ResourceTypeKind::ENTITY) {
+                    $currentResourceSetWrapper2 = $this->getCurrentResourceSetWrapper();
+                    $resourceProperties = $this->dataService
+                        ->getMetadataQueryProviderWrapper()
+                        ->getResourceProperties(
+                            $currentResourceSetWrapper2, 
+                            $resourceType
+                        );
                     //Check for the visibility of this navigation property
-                    if ( array_key_exists( $resourceProperty->getName(), $resourceProperties ) )
-                    {
-                        $navigationProperties[$i] = new NavigationPropertyInfo( $resourceProperty, $this->shouldExpandSegment( $propertyName ) );
-                        if ( $navigationProperties[$i]->expanded )
-                        {
-                            $navigationProperties[$i]->value = $this->getPropertyValue( $customObject, $resourceType, $resourceProperty );
-                        }
-                        
-                        $i ++;
-                        continue;
-                    }
-                }
-                
+                    if (array_key_exists($resourceProperty->getName(), $resourceProperties)) {
+                        $navigationProperties[$i] = new NavigationPropertyInfo($resourceProperty, $this->shouldExpandSegment($propertyName));
+                        if ($navigationProperties[$i]->expanded) {
+                            $navigationProperties[$i]->value = $this->getPropertyValue($customObject, $resourceType, $resourceProperty);
+                        }
+
+                        $i++;
+                        continue;
+                    }
+                }
+
                 //Primitve, complex or bag property
-                $propertyValue = $this->getPropertyValue( $customObject, $resourceType, $resourceProperty );
-                $propertyTypeKind = $resourceProperty->getKind();
-                $propertyResourceType = $resourceProperty->getResourceType();
-                $this->assert( ! is_null( $propertyResourceType ), '!is_null($propertyResourceType)' );
-                if ( ResourceProperty::sIsKindOf( $propertyTypeKind, ResourcePropertyKind::BAG ) )
-                {
-                    $bagResourceType = $resourceProperty->getResourceType();
-                    $this->_writeBagValue( $propertyValue, $propertyName, $bagResourceType, $relativeUri . '/' . $propertyName, $odataPropertyContent );
-                }
-                else 
-                    if ( ResourceProperty::sIsKindOf( $propertyTypeKind, ResourcePropertyKind::PRIMITIVE ) )
-                    {
-                        $odataProperty = new ODataProperty();
-                        $this->_writePrimitiveValue( $propertyValue, $resourceProperty, $odataProperty );
-                        $odataPropertyContent->odataProperty[] = $odataProperty;
-                    }
-                    else 
-                        if ( $propertyTypeKind == ResourcePropertyKind::COMPLEX_TYPE )
-                        {
-                            $complexResourceType = $resourceProperty->getResourceType();
-                            $this->_writeComplexValue( $propertyValue, $propertyName, $complexResourceType, $relativeUri . '/' . $propertyName, $odataPropertyContent );
-                        }
-                        else
-                        {
-                            //unexpected
-                            $this->assert( false, '$propertyTypeKind = Primitive or Bag or ComplexType' );
-                        }
-            }
-        }
-        
-        if ( ! is_null( $navigationProperties ) )
-        {
+                $propertyValue = $this->getPropertyValue($customObject, $resourceType, $resourceProperty);
+                $propertyTypeKind = $resourceProperty->getKind();
+                $propertyResourceType = $resourceProperty->getResourceType();
+                $this->assert(!is_null($propertyResourceType), '!is_null($propertyResourceType)');
+                if (ResourceProperty::sIsKindOf($propertyTypeKind, ResourcePropertyKind::BAG)) {
+                    $bagResourceType = $resourceProperty->getResourceType();
+                    $this->_writeBagValue(
+                        $propertyValue,
+                        $propertyName,
+                        $bagResourceType,
+                        $relativeUri . '/' . $propertyName,
+                        $odataPropertyContent
+                    );
+                } else if (ResourceProperty::sIsKindOf($propertyTypeKind, ResourcePropertyKind::PRIMITIVE)) {
+                    $odataProperty = new ODataProperty();
+                    $this->_writePrimitiveValue($propertyValue, $resourceProperty, $odataProperty);
+                    $odataPropertyContent->odataProperty[] = $odataProperty;
+                } else if ($propertyTypeKind == ResourcePropertyKind::COMPLEX_TYPE) {
+                    $complexResourceType = $resourceProperty->getResourceType();
+                    $this->_writeComplexValue(
+                        $propertyValue,
+                        $propertyName,
+                        $complexResourceType,
+                        $relativeUri . '/' . $propertyName,
+                        $odataPropertyContent
+                    );
+                } else {
+                    //unexpected
+                    $this->assert(false, '$propertyTypeKind = Primitive or Bag or ComplexType');
+                }
+            }
+        }
+
+        if (!is_null($navigationProperties)) {
             //Write out navigation properties (deferred or inline)
-            foreach ( $navigationProperties as $navigationPropertyInfo )
-            {
-                $propertyName = $navigationPropertyInfo->resourceProperty->getName();
-                $type = $navigationPropertyInfo->resourceProperty->getKind() == ResourcePropertyKind::RESOURCE_REFERENCE ? 'application/atom+xml;type=entry' : 'application/atom+xml;type=feed';
-                $link = new ODataLink();
-                $link->name = ODataConstants::ODATA_RELATED_NAMESPACE . $propertyName;
-                $link->title = $propertyName;
-                $link->type = $type;
-                $link->url = $relativeUri . '/' . $propertyName;
-                
-                if ( $navigationPropertyInfo->expanded )
-                {
-                    $propertyRelativeUri = $relativeUri . '/' . $propertyName;
-                    $propertyAbsoluteUri = trim( $absoluteUri, '/' ) . '/' . $propertyName;
-                    $needPop = $this->pushSegmentForNavigationProperty( $navigationPropertyInfo->resourceProperty );
-                    $navigationPropertyKind = $navigationPropertyInfo->resourceProperty->getKind();
-                    $this->assert( $navigationPropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE || $navigationPropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE, '$navigationPropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE 
-                        || $navigationPropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE' );
-                    $currentResourceSetWrapper = $this->getCurrentResourceSetWrapper();
-                    $this->assert( ! is_null( $currentResourceSetWrapper ), '!is_null($currentResourceSetWrapper)' );
-                    $link->isExpanded = true;
-                    if ( ! is_null( $navigationPropertyInfo->value ) )
-                    {
-                        if ( $navigationPropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE )
-                        {
-                            $inlineFeed = new ODataFeed();
-                            $link->isCollection = true;
-                            $currentResourceType = $currentResourceSetWrapper->getResourceType();
-                            $this->_writeFeedElements( $navigationPropertyInfo->value, $currentResourceType, $propertyName, $propertyAbsoluteUri, $propertyRelativeUri, $inlineFeed );
-                            $link->expandedResult = $inlineFeed;
-                        }
-                        else
-                        {
-                            $inlineEntry = new ODataEntry();
-                            $link->isCollection = false;
-                            $currentResourceType1 = $currentResourceSetWrapper->getResourceType();
-                            $this->_writeEntryElement( $navigationPropertyInfo->value, $currentResourceType1, $propertyAbsoluteUri, $propertyRelativeUri, $inlineEntry );
-                            $link->expandedResult = $inlineEntry;
-                        }
-                    }
-                    else
-                    {
-                        $link->expandedResult = null;
-                    }
-                    
-                    $this->popSegment( $needPop );
-                }
-                
-                $odataEntry->links[] = $link;
-            }
-            $test;
-        }
-    }
-
+            foreach ($navigationProperties as $navigationPropertyInfo) {
+                $propertyName = $navigationPropertyInfo->resourceProperty->getName();
+                $type = $navigationPropertyInfo->resourceProperty->getKind() == ResourcePropertyKind::RESOURCE_REFERENCE ? 
+                    'application/atom+xml;type=entry':
+                    'application/atom+xml;type=feed';
+                $link = new ODataLink();
+                $link->name = ODataConstants::ODATA_RELATED_NAMESPACE . $propertyName; 
+                $link->title = $propertyName;
+                $link->type = $type;
+                $link->url = $relativeUri . '/' . $propertyName;
+
+                if ($navigationPropertyInfo->expanded) {
+                    $propertyRelativeUri = $relativeUri . '/' . $propertyName;
+                    $propertyAbsoluteUri = trim($absoluteUri, '/') . '/' . $propertyName;
+                    $needPop = $this->pushSegmentForNavigationProperty($navigationPropertyInfo->resourceProperty);
+                    $navigationPropertyKind = $navigationPropertyInfo->resourceProperty->getKind();
+                    $this->assert(
+                        $navigationPropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE 
+                        || $navigationPropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE, 
+                        '$navigationPropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE 
+                        || $navigationPropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE'
+                    );
+                    $currentResourceSetWrapper = $this->getCurrentResourceSetWrapper();
+                    $this->assert(!is_null($currentResourceSetWrapper), '!is_null($currentResourceSetWrapper)');
+                    $link->isExpanded = true;
+                    if (!is_null($navigationPropertyInfo->value)) {
+                        if ($navigationPropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE) {
+                            $inlineFeed = new ODataFeed();
+                            $link->isCollection = true;
+                            $currentResourceType = $currentResourceSetWrapper->getResourceType();
+                            $this->_writeFeedElements(
+                                $navigationPropertyInfo->value,
+                                $currentResourceType, 
+                                $propertyName, 
+                                $propertyAbsoluteUri, 
+                                $propertyRelativeUri, 
+                                $inlineFeed
+                            );
+                            $link->expandedResult = $inlineFeed;
+                        } else {
+                            $inlineEntry = new ODataEntry();
+                            $link->isCollection = false;
+                            $currentResourceType1 = $currentResourceSetWrapper->getResourceType();
+                            $this->_writeEntryElement(
+                                $navigationPropertyInfo->value, 
+                                $currentResourceType1, 
+                                $propertyAbsoluteUri, 
+                                $propertyRelativeUri, 
+                                $inlineEntry
+                            );
+                            $link->expandedResult = $inlineEntry;
+                        }
+                    } else {
+                        $link->expandedResult = null;
+                    }
+
+                    $this->popSegment($needPop);
+                }
+
+                $odataEntry->links[] = $link;
+            }
+        }
+    }
+
     /**
      * Writes a primitive value and related information to the given
      * ODataProperty instance.
      * 
      * @param mixed            &$primitiveValue   The primitive value to write.
      * @param ResourceProperty &$resourceProperty The metadata of the primitive
-     * property value.
+     *                                            property value.
      * @param ODataProperty    &$odataProperty    ODataProperty instance to which
-     * the primitive value and related
-     * information to write out.
+     *                                            the primitive value and related
+     *                                            information to write out.
      *
      * @throws ODataException If given value is not primitive.
      * 
      * @return void
-     */
-    private function _writePrimitiveValue( &$primitiveValue, ResourceProperty &$resourceProperty, ODataProperty &$odataProperty )
-    {
-        if ( is_object( $primitiveValue ) )
-        {
+     */
+    private function _writePrimitiveValue(&$primitiveValue, 
+        ResourceProperty &$resourceProperty, ODataProperty &$odataProperty
+    ) {
+        if (is_object($primitiveValue)) {
             //TODO ERROR: The property 'PropertyName' 
-        //is defined as primitive type but value is an object
-        }
-        
-        $odataProperty->name = $resourceProperty->getName();
-        $odataProperty->typeName = $resourceProperty->getInstanceType()->getFullTypeName();
-        if ( is_null( $primitiveValue ) )
-        {
-            $odataProperty->value = null;
-        }
-        else
-        {
-            $resourceType = $resourceProperty->getResourceType();
-            $this->_primitiveToString( $resourceType, $primitiveValue, $odataProperty->value );
-        }
-    }
-
+            //is defined as primitive type but value is an object
+        }
+
+        
+        $odataProperty->name = $resourceProperty->getName();
+        $odataProperty->typeName = $resourceProperty->getInstanceType()->getFullTypeName();
+        if (is_null($primitiveValue)) {
+            $odataProperty->value = null;
+        } else {
+            $resourceType = $resourceProperty->getResourceType();
+            $this->_primitiveToString(
+                $resourceType,
+                $primitiveValue,
+                $odataProperty->value
+            );
+        }
+    }
+
     /**
      * Write value of a complex object.
      * 
      * @param mixed                &$complexValue         Complex object to write.
      * @param string               $propertyName          Name of the 
-     * complex property
-     * whose value need 
-     * to be written.
+     *                                                    complex property
+     *                                                    whose value need 
+     *                                                    to be written.
      * @param ResourceType         &$resourceType         Expected type 
-     * of the property.
+     *                                                    of the property.
      * @param string               $relativeUri           Relative uri for the 
-     * complex type element.
+     *                                                    complex type element.
      * @param ODataPropertyContent &$odataPropertyContent Content to write to.
      * 
      * @return void
-     */
-    private function _writeComplexValue( &$complexValue, $propertyName, ResourceType &$resourceType, $relativeUri, ODataPropertyContent &$odataPropertyContent )
-    {
-        $odataProperty = new ODataProperty();
-        $odataProperty->name = $propertyName;
-        if ( is_null( $complexValue ) )
-        {
-            $odataProperty->value = null;
-            $odataProperty->typeName = $resourceType->getFullName();
-        }
-        else
-        {
-            $content = new ODataPropertyContent();
-            $actualType = $this->_complexObjectToContent( $complexValue, $propertyName, $resourceType, $relativeUri, $content );
-            
-            $odataProperty->typeName = $actualType->getFullName();
-            $odataProperty->value = $content;
-        }
-        
-        $odataPropertyContent->odataProperty[] = $odataProperty;
-    }
-
+     */
+    private function _writeComplexValue(&$complexValue,
+        $propertyName, ResourceType &$resourceType, $relativeUri,
+        ODataPropertyContent &$odataPropertyContent
+    ) {
+        $odataProperty = new ODataProperty();
+        $odataProperty->name = $propertyName;
+        if (is_null($complexValue)) {
+            $odataProperty->value = null;
+            $odataProperty->typeName = $resourceType->getFullName();
+        } else {
+            $content = new ODataPropertyContent();
+            $actualType = $this->_complexObjectToContent(
+                $complexValue,
+                $propertyName,
+                $resourceType,
+                $relativeUri,
+                $content
+            );
+
+            $odataProperty->typeName = $actualType->getFullName();
+            $odataProperty->value = $content;
+        }
+
+        $odataPropertyContent->odataProperty[] = $odataProperty;
+    }
+
     /**
      * Write value of a bag instance.
      *
      * @param array/NULL           &$BagValue             Bag value to write.
      * @param string               $propertyName          Property name of the bag.
      * @param ResourceType         &$resourceType         Type describing the 
-     * bag value.
+     *                                                    bag value.
      * @param string               $relativeUri           Relative Url to the bag.
      * @param ODataPropertyContent &$odataPropertyContent On return, this object 
-     * will hold bag value which 
-     * can be used by writers.
+     *                                                    will hold bag value which 
+     *                                                    can be used by writers.
      * 
      * @return void
-     */
-    private function _writeBagValue( &$BagValue, $propertyName, ResourceType &$resourceType, $relativeUri, ODataPropertyContent &$odataPropertyContent )
-    {
-        $bagItemResourceTypeKind = $resourceType->getResourceTypeKind();
-        $this->assert( $bagItemResourceTypeKind == ResourceTypeKind::PRIMITIVE || $bagItemResourceTypeKind == ResourceTypeKind::COMPLEX, '$bagItemResourceTypeKind == ResourceTypeKind::PRIMITIVE
-            || $bagItemResourceTypeKind == ResourceTypeKind::COMPLEX' );
-        
-        $odataProperty = new ODataProperty();
-        $odataProperty->name = $propertyName;
-        $odataProperty->typeName = 'Collection(' . $resourceType->getFullName() . ')';
-        if ( is_null( $BagValue ) || ( is_array( $BagValue ) && empty( $BagValue ) ) )
-        {
-            $odataProperty->value = null;
-        }
-        else
-        {
-            $odataBagContent = new ODataBagContent();
-            foreach ( $BagValue as $itemValue )
-            {
-                if ( ! is_null( $itemValue ) )
-                {
-                    if ( $bagItemResourceTypeKind == ResourceTypeKind::PRIMITIVE )
-                    {
-                        $primitiveValueAsString = null;
-                        $this->_primitiveToString( $resourceType, $itemValue, $primitiveValueAsString );
-                        $odataBagContent->propertyContents[] = $primitiveValueAsString;
-                    }
-                    else 
-                        if ( $bagItemResourceTypeKind == ResourceTypeKind::COMPLEX )
-                        {
-                            $complexContent = new ODataPropertyContent();
-                            $actualType = $this->_complexObjectToContent( $itemValue, $propertyName, $resourceType, $relativeUri, $complexContent );
-                            //TODO add type in case of base type
-                            $odataBagContent->propertyContents[] = $complexContent;
-                        }
-                }
-            }
-            
-            $odataProperty->value = $odataBagContent;
-        }
-        
-        $odataPropertyContent->odataProperty[] = $odataProperty;
-    }
-
+     */
+    private function _writeBagValue(&$BagValue,
+        $propertyName, ResourceType &$resourceType, $relativeUri,
+        ODataPropertyContent &$odataPropertyContent
+    ) {
+        $bagItemResourceTypeKind = $resourceType->getResourceTypeKind();
+        $this->assert(
+            $bagItemResourceTypeKind == ResourceTypeKind::PRIMITIVE
+            || $bagItemResourceTypeKind == ResourceTypeKind::COMPLEX,
+            '$bagItemResourceTypeKind == ResourceTypeKind::PRIMITIVE
+            || $bagItemResourceTypeKind == ResourceTypeKind::COMPLEX'
+        );
+
+        $odataProperty = new ODataProperty();
+        $odataProperty->name = $propertyName;
+        $odataProperty->typeName = 'Collection(' . $resourceType->getFullName() .')';
+        if (is_null($BagValue) || (is_array($BagValue) && empty ($BagValue))) {
+            $odataProperty->value = null;
+        } else {
+            $odataBagContent = new ODataBagContent();
+            foreach ($BagValue as $itemValue) {
+                if (!is_null($itemValue)) {
+                    if ($bagItemResourceTypeKind == ResourceTypeKind::PRIMITIVE) {
+                        $primitiveValueAsString = null;
+                        $this->_primitiveToString($resourceType, $itemValue, $primitiveValueAsString);
+                        $odataBagContent->propertyContents[] = $primitiveValueAsString;
+                    } else if ($bagItemResourceTypeKind == ResourceTypeKind::COMPLEX) {
+                        $complexContent = new ODataPropertyContent();
+                        $actualType = $this->_complexObjectToContent(
+                            $itemValue,
+                            $propertyName,
+                            $resourceType,
+                            $relativeUri,
+                            $complexContent
+                        );
+                        //TODO add type in case of base type
+                        $odataBagContent->propertyContents[] = $complexContent;
+                    }
+                }
+            }
+
+            $odataProperty->value = $odataBagContent;
+        }
+
+        $odataPropertyContent->odataProperty[] = $odataProperty;
+    }
+
     /**
      * Write media resource metadata (for MLE and Named Streams)
      * 
      * @param mixed        &$entryObject  The entry instance being serialized.
      * @param ResourceType &$resourceType Resource type of the entry instance.
      * @param string       $title         Title for the current 
-     * current entry instance.
+     *                                    current entry instance.
      * @param string       $relativeUri   Relative uri for the 
-     * current entry instance.
+     *                                    current entry instance.
      * @param ODataEntry   &$odataEntry   OData entry to write to.
      * 
      * @return void
-     */
-    private function _writeMediaResourceMetadata( &$entryObject, ResourceType &$resourceType, $title, $relativeUri, ODataEntry &$odataEntry )
-    {
-        if ( $resourceType->isMediaLinkEntry() )
-        {
-            $odataEntry->isMediaLinkEntry = true;
-            $streamProvider = $this->dataService->getStreamProvider();
-            $eTag = $streamProvider->getStreamETag( $entryObject, null );
-            $readStreamUri = $streamProvider->getReadStreamUri( $entryObject, null, $relativeUri );
-            $mediaContentType = $streamProvider->getStreamContentType( $entryObject, null );
-            $mediaLink = new ODataMediaLink( $title, $streamProvider->getDefaultStreamEditMediaUri( $relativeUri, null ), $readStreamUri, $mediaContentType, $eTag );
-            
-            $odataEntry->mediaLink = $mediaLink;
-        }
-        
-        if ( $resourceType->hasNamedStream() )
-        {
-            foreach ( $resourceType->getAllNamedStreams() as $title => $resourceStreamInfo )
-            {
-                $eTag = $streamProvider->getStreamETag( $entryObject, $resourceStreamInfo );
-                $readStreamUri = $streamProvider->getReadStreamUri( $entryObject, $resourceStreamInfo, $relativeUri );
-                $mediaContentType = $streamProvider->getStreamContentType( $entryObject, $resourceStreamInfo );
-                $odataEntry->mediaLinks[] = new ODataMediaLink( $title, $streamProvider->getDefaultStreamEditMediaUri( $relativeUri, $resourceStreamInfo ), $readStreamUri, $mediaContentType, $eTag );
-            }
-        }
-    }
-
+     */
+    private function _writeMediaResourceMetadata(&$entryObject,
+        ResourceType &$resourceType,
+        $title,
+        $relativeUri,
+        ODataEntry &$odataEntry
+    ) {
+        if ($resourceType->isMediaLinkEntry()) {
+            $odataEntry->isMediaLinkEntry = true;
+            $streamProvider = $this->dataService->getStreamProvider();
+            $eTag = $streamProvider->getStreamETag($entryObject, null);
+            $readStreamUri = $streamProvider->getReadStreamUri($entryObject, null, $relativeUri);
+            $mediaContentType = $streamProvider->getStreamContentType($entryObject, null);
+            $mediaLink = new ODataMediaLink(
+                $title,
+                $streamProvider->getDefaultStreamEditMediaUri($relativeUri, null),
+                $readStreamUri,
+                $mediaContentType,
+                $eTag
+            );
+
+            $odataEntry->mediaLink = $mediaLink;
+        }
+
+        if ($resourceType->hasNamedStream()) {
+            foreach ($resourceType->getAllNamedStreams() as $title => $resourceStreamInfo) {
+                $eTag = $streamProvider->getStreamETag($entryObject, $resourceStreamInfo);
+                $readStreamUri = $streamProvider->getReadStreamUri($entryObject, $resourceStreamInfo, $relativeUri);
+                $mediaContentType = $streamProvider->getStreamContentType($entryObject, $resourceStreamInfo);
+                $odataEntry->mediaLinks[] = new ODataMediaLink(
+                    $title,
+                    $streamProvider->getDefaultStreamEditMediaUri($relativeUri, $resourceStreamInfo),
+                    $readStreamUri,
+                    $mediaContentType,
+                    $eTag
+                );
+            }
+        }
+    }
     /**
      * Convert the given primitive value to string.
      * Note: This method will not handle null primitive value.
      * 
      * @param ResourceType &$primtiveResourceType Type of the primitive property
-     * whose value need to be converted.
+     *                                            whose value need to be converted.
      * @param mixed        $primitiveValue        Primitive value to convert.
      * @param string       &$stringValue          On return, this parameter will
-     * contain converted value.
-     * 
+     *                                            contain converted value.
+     *                                            
      * @return void
-     */
-    private function _primitiveToString( ResourceType &$primtiveResourceType, $primitiveValue, &$stringValue )
-    {
-        $type = $primtiveResourceType->getInstanceType();
-        if ( $type instanceof Boolean )
-        {
-            $stringValue = ( $primitiveValue === true ) ? 'true' : 'false';
-        }
-        else 
-            if ( $type instanceof Binary )
-            {
-                $stringValue = base64_encode( $primitiveValue );
-            }
-            else 
-                if ( $type instanceof String )
-                {
-                	#@TODO bjoern, odata bug
-                    #$stringValue = utf8_encode( $primitiveValue );
-                    $stringValue = $primitiveValue;
-                }
-                else
-                {
-                    $stringValue = strval( $primitiveValue );
-                }
-    }
-
+     */
+    private function _primitiveToString(ResourceType &$primtiveResourceType,
+        $primitiveValue, &$stringValue
+    ) {
+        $type = $primtiveResourceType->getInstanceType();
+        if ($type instanceof Boolean) {
+            $stringValue = ($primitiveValue === true) ? 'true' : 'false';
+        } else if ($type instanceof Binary) {
+                $stringValue = base64_encode($primitiveValue);
+        } else if ($type instanceof String) {
+            $stringValue = utf8_encode($primitiveValue);
+        } else {        
+            $stringValue = strval($primitiveValue);
+        }
+    }
+
     /**
      * Write value of a complex object.
      * Note: This method will not handle null complex value.
      *
      * @param mixed                &$complexValue         Complex object to write.
      * @param string               $propertyName          Name of the 
-     * complex property
-     * whose value 
-     * need to be written.
+     *                                                    complex property
+     *                                                    whose value 
+     *                                                    need to be written.
      * @param ResourceType         &$resourceType         Expected type of the 
-     * property.
+     *                                                    property.
      * @param string               $relativeUri           Relative uri for the 
-     * complex type element.
+     *                                                    complex type element.
      * @param ODataPropertyContent &$odataPropertyContent Content to write to.
      *
      * @return ResourceType The actual type of the complex object.
      * 
      * @return void
-     */
-    private function _complexObjectToContent( &$complexValue, $propertyName, ResourceType &$resourceType, $relativeUri, ODataPropertyContent &$odataPropertyContent )
-    {
-        $count = count( $this->complexTypeInstanceCollection );
-        for ( $i = 0; $i < $count; $i ++ )
-        {
-            if ( $this->complexTypeInstanceCollection[$i] === $complexValue )
-            {
-                throw new InvalidOperationException( Messages::objectModelSerializerLoopsNotAllowedInComplexTypes( $propertyName ) );
-            }
-        }
-        
-        $this->complexTypeInstanceCollection[$count] = &$complexValue;
-        
-        /**
-         * TODO function to resolve actual type from $resourceType
-        //@TODO bjoern
-        #if (class_exists($resourceType)){
-        #	$convert = new $resourceType();
-        #	$convert->convert( $complexValue, $odataPropertyContent );
-        #}
-        # var_dump($odataPropertyContent);
-        # die("asda");
-        
-        //$complexValue = str_replace( '<?xml version="1.0" encoding="utf-8"?>'. "\n", '', $complexValue);
-        #$odataPropertyContent = $complexValue;
-         **/
-        $absoluteUri = null;
-        $entity = null;
-
-        if ( is_array( $complexValue ) )
-        {
-            $converter = new xrowObject2XML( "list" );
-            $odataPropertyContent = $converter->toXml( $complexValue );
-        }
-        elseif ( is_string( $complexValue ) )
-        {
-            $odataPropertyContent = simplexml_load_string( $complexValue );
-        }
-        elseif ( $complexValue instanceof DOMDocument )
-        {
-        	$odataPropertyContent = simplexml_import_dom( $complexValue );
-        }
-
-        $actualType = $resourceType;
-        $odataEntry = null;
-        
-        #$this->_writeObjectProperties(
-        #    $complexValue, $actualType,
-        #    null, $relativeUri, $odataEntry, $odataPropertyContent
-        #);
-        unset( $this->complexTypeInstanceCollection[$count] );
-        return $actualType;
-    }
-}
-
+     */
+    private function _complexObjectToContent(&$complexValue,
+        $propertyName, ResourceType &$resourceType, $relativeUri,
+        ODataPropertyContent &$odataPropertyContent
+    ) {
+        $count = count($this->complexTypeInstanceCollection);
+        for ($i = 0; $i < $count; $i++) {
+            if ($this->complexTypeInstanceCollection[$i] === $complexValue) {
+                throw new InvalidOperationException(Messages::objectModelSerializerLoopsNotAllowedInComplexTypes($propertyName));
+            }
+        }
+
+        $this->complexTypeInstanceCollection[$count] = &$complexValue;
+
+        //TODO function to resolve actual type from $resourceType
+        $actualType = $resourceType;
+        $odataEntry = null;
+        $this->_writeObjectProperties(
+            $complexValue, $actualType,
+            null, $relativeUri, $odataEntry, $odataPropertyContent
+        );
+        unset($this->complexTypeInstanceCollection[$count]);
+        return $actualType;
+    }
+}
 ?>
\ No newline at end of file
Index: library/ODataProducer/OperationContext/DataServiceHost.php
===================================================================
--- library/ODataProducer/OperationContext/DataServiceHost.php	(revision 2307)
+++ library/ODataProducer/OperationContext/DataServiceHost.php	(working copy)
@@ -195,7 +195,6 @@
             }
 
             $segments = $this->_absoluteServiceUri->getSegments();
-
             $lastSegment = $segments[count($segments) - 1];
             $endsWithSvc 
                 = (substr_compare($lastSegment, '.svc', -strlen('.svc'), strlen('.svc')) === 0);
Index: library/ODataProducer/Providers/Metadata/ResourceType.php
===================================================================
--- library/ODataProducer/Providers/Metadata/ResourceType.php	(revision 2307)
+++ library/ODataProducer/Providers/Metadata/ResourceType.php	(working copy)
@@ -1,943 +1,943 @@
-<?php
-/**
- * A type to describe an entity type, complex type or primitive type
- * 
- * PHP version 5.3
- * 
- * @category  ODataProducer
- * @package   ODataProducer_Providers_Metadata
- * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   SVN: 1.0
- * @link      http://odataphpproducer.codeplex.com
- * 
- */
-namespace ODataProducer\Providers\Metadata;
-use ODataProducer\Providers\Metadata\Type\Binary;
-use ODataProducer\Providers\Metadata\Type\Boolean;
-use ODataProducer\Providers\Metadata\Type\Byte;
-use ODataProducer\Providers\Metadata\Type\DateTime;
-use ODataProducer\Providers\Metadata\Type\Decimal;
-use ODataProducer\Providers\Metadata\Type\Double;
-use ODataProducer\Providers\Metadata\Type\Guid;
-use ODataProducer\Providers\Metadata\Type\Int16;
-use ODataProducer\Providers\Metadata\Type\Int32;
-use ODataProducer\Providers\Metadata\Type\Int64;
-use ODataProducer\Providers\Metadata\Type\SByte;
-use ODataProducer\Providers\Metadata\Type\Single;
-use ODataProducer\Providers\Metadata\Type\String;
-use ODataProducer\Providers\Metadata\Type\TypeCode;
-use ODataProducer\Providers\Metadata\Type\EdmPrimitiveType;
-use ODataProducer\Providers\Metadata\Type\IType;
-use ODataProducer\Common\Messages;
-use ODataProducer\Common\InvalidOperationException;
-use ODataProducer\Common;
-/**
- * A type to describe an entity type, complex type or primitive type.
- * 
- * @category  ODataProducer
- * @package   ODataProducer_Providers_Metadata
- * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   Release: 1.0
- * @link      http://odataphpproducer.codeplex.com
- */
-class ResourceType
-{
-    /**
-     * Name of the resource described by this class instance.
-     * 
-     * @var string
-     */
-    private $_name;
-
-    /**
-     * Namespace name in which resource described by this class instance
-     * belongs to.
-     * 
-     * @var string
-     */
-    private $_namespaceName;
-
-    /**
-     * The fully qualified name of the resource described by this class instance.
-     * 
-     * @var string
-     */
-    private $_fullName;
-
-    /**
-     * The type the resource described by this class instance.
-     * Note: either Entity or Complex Type
-     * 
-     * @var  ResourceTypeKind
-     */
-    private $_resourceTypeKind;
-
-    /**
-     * @var boolean
-     */
-    private $_abstractType;
-
-    /**
-     * Refrence to ResourceType instance for base type, if any.
-     * 
-     * @var ResourceType
-     */
-    private $_baseType;
-
-    /** 
-     * Collection of ResourceProperty for all properties declared on the
-     * resource described by this class instance (This does not include 
-     * base type properties).
-     * 
-     * @var array(string, ResourceProperty)
-     */
-    private $_propertiesDeclaredOnThisType = array();
-
-    /**
-     * Collection of ResourceStreamInfo for all named streams declared on 
-     * the resource described by this class instance (This does not include 
-     * base type properties).
-     * 
-     * @var array(string, ResourceStreamInfo)
-     */
-    private $_namedStreamsDeclaredOnThisType = array();
-
-    /**
-     * Collection of ReflectionProperty instances for each property declared 
-     * on this type
-     * 
-     * @var array(ResourceProperty, ReflectionProperty)
-     */
-    private $_propertyInfosDeclaredOnThisType = array();
-
-    /**
-     * Collection of ResourceProperty for all properties declared on this type.
-     * and base types.
-     * 
-     * @var array(string, ResourceProperty)
-     */    
-    private $_allProperties = array();
-
-    /**
-     * Collection of ResourceStreamInfo for all named streams declared on this type.
-     * and base types
-     * 
-     * @var array(string, ResourceStreamInfo)
-     */
-    private $_allNamedStreams = array();
-
-    /**      
-     * Collection of properies which has etag defined subeset of $_allProperies
-     * @var array(ResourceProperty)
-     */
-    private $_etagProperties = array();
-
-    /** 
-     * Collection of key properies subeset of $_allProperies
-     * 
-     * @var array(ResourceProperty)
-     */
-    private $_keyProperties = array();
-
-    /**      
-     * Whether the resource type described by this class intance is a MLE or not
-     * 
-     * @var boolean
-     */
-    private $_isMediaLinkEntry = false;
-
-    /**
-     * Whether the resource type described by this class instance has bag properties
-     * Note: This has been intitialized with null, later in hasBagProperty method, 
-     * this flag will be set to boolean value
-     * 
-     * @var boolean
-     */
-    private $_hasBagProperty = null;
-
-    /**
-     * Whether the resource type described by this class instance has named streams
-     * Note: This has been intitialized with null, later in hasNamedStreams method, 
-     * this flag will be set to boolean value
-     * 
-     * @var boolean
-     */
-    private $_hasNamedStreams = null;
-
-    /**     
-     * ReflectionClass (for complex/Entity) or IType (for Primitive) instance for 
-     * the resource (type) described by this class intstance
-     * 
-     * @var ReflectionClass/IType
-     */
-    private $_type;
-
-    /**
-     * To store any custom information related to this class intstance
-     * 
-     * @var Object
-     */
-    private $_customState; 
-
-    /**
-     * Array to detect looping in bag's complex type  
-     * 
-     * @var array(mixed)
-     */
-    private $_arrayToDetectLoopInComplexBag;
-
-    /**
-     * Create new instance of ResourceType
-     * 
-     * @param ReflectionClass/IType $instanceType     Instance type for the resource,
-     *                                                for entity and 
-     *                                                complex this will 
-     *                                                be 'ReflectionClass' and for 
-     *                                                primitive type this 
-     *                                                will be IType
-     * @param ResourceTypeKind      $resourceTypeKind Kind of resource 
-     *                                               (Entity, Complex or Primitive)
-     * @param string                $name             Name of the resource
-     * @param string                $namespaceName    Namespace of the resource
-     * @param ResourceType          $baseType         Base type of the 
-     *                                                resource, if exists 
-     * @param boolean               $isAbstract       Whether resource is abstract
-     * 
-     * @throws InvalidArgumentException
-     */
-    public function __construct($instanceType, $resourceTypeKind, $name, 
-        $namespaceName = null, ResourceType $baseType = null, 
-        $isAbstract = false
-    ) {
-        $this->_type = $instanceType;
-        if ($resourceTypeKind == ResourceTypeKind::PRIMITIVE) {
-            if ($baseType != null) {
-                throw new \InvalidArgumentException(
-                    Messages::resourceTypeNoBaseTypeForPrimitive()
-                );
-            }
-
-            if ($isAbstract) {
-                throw new \InvalidArgumentException(
-                    Messages::resourceTypeNoAbstractForPrimitive()
-                );
-            }
-
-            if (!($instanceType instanceof IType)) {
-                throw new \InvalidArgumentException(
-                    Messages::resourceTypeTypeShouldImplementIType('$instanceType')
-                );
-            }
-        } else {
-            if (!($instanceType instanceof \ReflectionClass)) {
-                throw new \InvalidArgumentException(
-                    Messages::resourceTypeTypeShouldReflectionClass('$instanceType')
-                );
-            }
-        }
-
-        $this->_resourceTypeKind = $resourceTypeKind;
-        $this->_name = $name;
-        $this->_baseType = $baseType;        
-        $this->_namespaceName = $namespaceName; 
-        $this->_fullName 
-            = is_null($namespaceName) ? $name : $namespaceName . '.' . $name;
-        $this->_abstractType = $isAbstract;
-        $this->_isMediaLinkEntry = false;
-        $this->_customState = null;
-        $this->_arrayToDetectLoopInComplexBag = array();
-        //TODO: Set MLE if base type has MLE Set
-    }
-
-    /**
-     * Get reference to ResourceType for base class
-     * 
-     * @return ResourceType
-     */
-    public function getBaseType()
-    {
-        return $this->_baseType;
-    }
-
-    /**
-     * To check whether this resource type has base type
-     * 
-     * @return boolean True if base type is defined, false otherwise
-     */
-    public function hasBaseType()
-    {
-        return !is_null($this->_baseType);
-    }
-
-    /**
-     * To get custom state object for this type
-     * 
-     * @return Object
-     */
-    public function getCustomState()
-    {
-        return $this->_customState;
-    }
-
-    /**
-     * To set custom state object for this type
-     * 
-     * @param Object $object The custom object.
-     * 
-     * @return void
-     */
-    public function setCustomState($object)
-    {
-        $this->_customState = $object;
-    }
-
-    /**
-     * Get the instance type. If the resource type describes a complex or entity type
-     * then this function returns refernece to ReflectionClass instance for the type.
-     * If resource type describes a primitive type then this function returns ITYpe.
-     * 
-     * @return ReflectionClass/IType
-     */
-    public function getInstanceType()
-    {
-        return $this->_type;
-    }
-
-    /**
-     * Get name of the type described by this resource type
-     * 
-     * @return string
-     */
-    public function getName()
-    {
-        return $this->_name;
-    }
-
-    /**
-     * Get the namespace under which the type described by this resource type is
-     * defined.
-     * 
-     * @return string
-     */
-    public function getNamespace()
-    {
-        return $this->_namespaceName;
-    }
-
-    /**
-     * Get full name (namespacename.typename) of the type described by this resource 
-     * type.
-     * 
-     * @return string
-     */
-    public function getFullName()
-    {
-        return $this->_fullName;
-    }
-
-    /**
-     * To check whether the type described by this resource type is abstract or not
-     * 
-     * @return boolean True if type is abstract else False
-     */
-    public function isAbstract()
-    {
-        return $this->_abstractType;
-    }
-
-    /**
-     * To get the kind of type described by this resource class
-     * 
-     * @return ResourceTypeKind
-     */
-    public function getResourceTypeKind()
-    {
-        return $this->_resourceTypeKind;
-    }
-
-    /**
-     * To check whether the type described by this resource type is MLE
-     * 
-     * @return boolean True if type is MLE else False
-     */
-    public function isMediaLinkEntry()
-    {
-        return $this->_isMediaLinkEntry;
-    }
-
-    /**
-     * Set the resource type as MLE or non-MLE
-     * 
-     * @param boolean $isMLE True to set as MLE, false for non-MLE
-     * 
-     * @return void
-     */
-    public function setMediaLinkEntry($isMLE)
-    {
-        if ($this->_resourceTypeKind != ResourceTypeKind::ENTITY) {
-            throw new InvalidOperationException(
-                Messages::resourceTypeHasStreamAttributeOnlyAppliesToEntityType()
-            );
-        }
-
-        $this->_isMediaLinkEntry = $isMLE;
-    }
-
-    /**      
-     * Add a property belongs to this resource type instance
-     * 
-     * @param ResourceProperty $property Property to add
-     * 
-     * @throws InvalidOperationException
-     * @return void
-     */
-    public function addProperty(ResourceProperty $property)
-    {
-        if ($this->_resourceTypeKind == ResourceTypeKind::PRIMITIVE) {
-            throw new InvalidOperationException(
-                Messages::resourceTypeNoAddPropertyForPrimitive()
-            );
-        }
-
-        $name = $property->getName();
-        foreach (array_keys($this->_propertiesDeclaredOnThisType) as $propertyName) {
-            if (strcasecmp($propertyName, $name) == 0) {
-                throw new InvalidOperationException(
-                    Messages::resourceTypePropertyWithSameNameAlreadyExists(
-                        $propertyName, $this->_name
-                    )
-                );
-            }
-        }
-
-        if ($property->isKindOf(ResourcePropertyKind::KEY)) {
-            if ($this->_resourceTypeKind != ResourceTypeKind::ENTITY) {
-                throw new InvalidOperationException(
-                    Messages::resourceTypeKeyPropertiesOnlyOnEntityTypes()
-                );
-            }
-
-            if ($this->_baseType != null) {
-                throw new InvalidOperationException(
-                    Messages::resourceTypeNoKeysInDerivedTypes()
-                );
-            }
-        }
-
-        if ($property->isKindOf(ResourcePropertyKind::ETAG) 
-            && ($this->_resourceTypeKind != ResourceTypeKind::ENTITY)
-        ) {
-            throw new InvalidOperationException(
-                Messages::resourceTypeETagPropertiesOnlyOnEntityTypes()
-            );
-        }
-
-        //Check for Base class properties
-        $this->_propertiesDeclaredOnThisType[$name] = $property;
-        // Set $this->_allProperties to null, this is very important because the 
-        // first call to getAllProperties will initilaize $this->_allProperties, 
-        // further call to getAllProperties will not reinitialize _allProperties
-        // so if addProperty is called after calling getAllProperties then the 
-        // property just added will not be reflected in $this->_allProperties
-        unset($this->_allProperties);
-        $this->_allProperties = array();
-    }
-
-    /**
-     * Get collection properties belongs to this resource type (excluding base class
-     * properties). This function returns  empty array in case of resource type
-     * for primitive types.
-     * 
-     * @return array(name, ResourceProperty)
-     */
-    public function getPropertiesDeclaredOnThisType()
-    {
-        return $this->_propertiesDeclaredOnThisType;
-    }
-
-    /**
-     * Get collection properties belongs to this resource type including base class
-     * properties. This function returns  empty array in case of resource type
-     * for primitive types.
-     * 
-     * @return array(name, ResourceProperty)
-     */
-    public function getAllProperties()
-    {
-        if (empty($this->_allProperties)) {
-            if ($this->_baseType != null) {
-                $this->_allProperties = $this->_baseType->getAllProperties();
-            }
-
-            $this->_allProperties = array_merge(
-                $this->_allProperties, $this->_propertiesDeclaredOnThisType
-            );
-        }
-
-        return $this->_allProperties;
-    }
-
-    /**     
-     * Get collection key properties belongs to this resource type. This 
-     * function returns non-empty array only for resource type representing 
-     * an entity type.
-     *  
-     * @return array(name, ResourceProperty)
-     */
-    public function getKeyProperties()
-    {
-        if (empty($this->_keyProperties)) {
-            $baseType = $this;
-            while ($baseType->_baseType != null) {
-                $baseType = $baseType->_baseType;
-            }
-
-            foreach ($baseType->_propertiesDeclaredOnThisType 
-                as $propertyName => $resourceProperty
-            ) {
-                if ($resourceProperty->isKindOf(ResourcePropertyKind::KEY)) {
-                    $this->_keyProperties[$propertyName] = $resourceProperty;
-                }
-            }
-        }
-
-        return $this->_keyProperties;
-    }
-
-    /**
-     * Get collection of e-tag properties belongs to this type.
-     * 
-     * @return array(name, ResourceProperty)
-     */
-    public function getETagProperties()
-    {
-        if (empty ($this->_etagProperties)) {
-            foreach ($this->getAllProperties() 
-                as $propertyName => $resourceProperty
-            ) {
-                if ($resourceProperty->isKindOf(ResourcePropertyKind::ETAG)) {
-                    $this->_etagProperties[$propertyName] = $resourceProperty;
-                }
-            }
-        }
-
-        return $this->_etagProperties;
-    }
-
-    /**
-     * To check this type has any eTag properties
-     * 
-     * @return boolean
-     */
-    public function hasETagProperties()
-    {
-        $this->getETagProperties();
-        return !empty($this->_etagProperties);
-    }
-
-    /**
-     * Try to get ResourceProperty for a property defined for this resource type
-     * excluding base class properties
-     * 
-     * @param string $propertyName The name of the property to resolve.
-     * 
-     * @return ResourceProperty or NULL
-     */
-    public function tryResolvePropertyTypeDeclaredOnThisTypeByName($propertyName)
-    {
-        if (array_key_exists($propertyName, $this->_propertiesDeclaredOnThisType)) {
-            return $this->_propertiesDeclaredOnThisType[$propertyName];
-        }
-
-        return null;
-    }
-
-    /** 
-     * Try to get ResourceProperty for a property defined for this resource type
-     * including base class properties
-     * 
-     * @param string $propertyName The name of the property to resolve.
-     * 
-     * @return ResourceProperty or NULL
-     */
-    public function tryResolvePropertyTypeByName($propertyName)
-    {
-        if (array_key_exists($propertyName, $this->getAllProperties())) {
-            return $this->_allProperties[$propertyName];
-        }
-
-        return null;
-    }
-
-    /**
-     * Add a named stream belongs to this resource type instance
-     * 
-     * @param ResourceStreamInfo $namedStream ResourceStreamInfo instance describing
-     *                                        the named stream to add.
-     * 
-     * @return void
-     * 
-     * @throws InvalidOperationException
-     */
-    public function addNamedStream(ResourceStreamInfo $namedStream)
-    {
-        if ($this->_resourceTypeKind != ResourceTypeKind::ENTITY) {
-            throw new InvalidOperationException(
-                Messages::resourceTypeNamedStreamsOnlyApplyToEntityType()
-            );
-        }
-
-        $name = $namedStream->getName();
-        foreach (array_keys($this->_namedStreamsDeclaredOnThisType) 
-            as $namedStreamName
-        ) {
-            if (strcasecmp($namedStreamName, $name) == 0) {
-                throw new InvalidOperationException(
-                    Messages::resourceTypeNamedStreamWithSameNameAlreadyExists(
-                        $name, $this->_name
-                    )
-                );
-            }
-        }
-
-        $this->_namedStreamsDeclaredOnThisType[$name] = $namedStream;
-        // Set $this->_allNamedStreams to null, the first call to getAllNamedStreams
-        // will initilaize $this->_allNamedStreams, further call to 
-        // getAllNamedStreams will not reinitialize _allNamedStreams
-        // so if addNamedStream is called after calling getAllNamedStreams then the
-        // property just added will not be reflected in $this->_allNamedStreams
-        unset($this->_allNamedStreams);
-        $this->_allNamedStreams = array();
-    }
-
-    /**
-     * Get collection of ResourceStreamInfo describing the named streams belongs 
-     * to this resource type (excluding base class properties)
-     * 
-     * @return array(name, ResourceStreamInfo)
-     */
-    public function getNamedStreamsDeclaredOnThisType()
-    {
-        return $this->_namedStreamsDeclaredOnThisType;
-    }
-
-    /**
-     * Get collection of ResourceStreamInfo describing the named streams belongs 
-     * to this resource type including base class named streams.
-     * 
-     * @return array(name, ResourceStreamInfo)
-     */
-    public function getAllNamedStreams()
-    {
-        if (empty($this->_allNamedStreams)) {
-            if ($this->_baseType != null) {
-                $this->_allNamedStreams = $this->_baseType->getAllNamedStreams();
-            }
-
-            $this->_allNamedStreams 
-                = array_merge(
-                    $this->_allNamedStreams, 
-                    $this->_namedStreamsDeclaredOnThisType
-                );
-        }
-
-        return $this->_allNamedStreams;
-    }
-
-    /** 
-     * Try to get ResourceStreamInfo for a named stream defined for this
-     * resource type excluding base class named streams
-     * 
-     * @param string $namedStreamName Name of the named stream to resolve.
-     * 
-     * @return ResourceStreamInfo or NULL
-     */
-    public function tryResolveNamedStreamDeclaredOnThisTypeByName($namedStreamName)
-    {
-        if (array_key_exists($namedStreamName, $this->_namedStreamsDeclaredOnThisType)) {
-            return $this->_namedStreamsDeclaredOnThisType[$namedStreamName];
-        }
-
-        return null;
-    }
-
-    /** 
-     * Try to get ResourceStreamInfo for a named stream defined for this resource 
-     * type including base class named streams
-     * 
-     * @param string $namedStreamName Name of the named stream to resolve.
-     * 
-     * @return ResourceStreamInfo or NULL
-     */
-    public function tryResolveNamedStreamByName($namedStreamName)
-    {
-        if (array_key_exists($namedStreamName, $this->getAllNamedStreams())) {
-            return $this->_allNamedStreams[$namedStreamName];
-        }
-
-        return null;
-    }
-
-    /**
-     * Check this resource type instance has named stream associated with it
-     * Note: This is an internal method used by library. Devs don't use this.
-     * 
-     * @return boolean true if resource type instance has named stream else false
-     */
-    public function hasNamedStream()
-    {   
-        // Note: Calling this method will initialize _allNamedStreams 
-        // and _hasNamedStreams flag to a boolean value
-        // from null depending on the current state of _allNamedStreams 
-        // array, so method should be called only after adding all 
-        // named streams
-        if (is_null($this->_hasNamedStreams)) {
-            $this->getAllNamedStreams();
-            $this->_hasNamedStreams = !empty($this->_allNamedStreams);
-        }
-        
-        return $this->_hasNamedStreams;
-    }
-
-    /**
-     * Check this resource type instance has bag property associated with it
-     * Note: This is an internal method used by library. Devs don't use this.
-     * 
-     * @param array(mixed) &$arrayToDetectLoopInComplexType array for detecting loop.
-     * 
-     * @return boolean true if resource type instance has bag property else false
-     */
-    public function hasBagProperty(&$arrayToDetectLoopInComplexType)
-    {        
-        // Note: Calling this method will initialize _bagProperties 
-        // and _hasBagProperty flag to a boolean value
-        // from null depending on the current state of 
-        // _propertiesDeclaredOnThisType array, so method
-        // should be called only after adding all properties
-        if (is_null($this->_hasBagProperty)) {
-            if ($this->_baseType != null 
-                && $this->_baseType->hasBagProperty($arrayToDetectLoopInComplexType)
-            ) {
-                        $this->_hasBagProperty = true;
-            } else {
-                foreach ($this->_propertiesDeclaredOnThisType as $resourceProperty) {
-                    $hasBagInComplex = false;
-                    if ($resourceProperty->isKindOf(ResourcePropertyKind::COMPLEX_TYPE)) {
-                        //We can say current ResouceType ("this") 
-                        //is contains a bag property if:
-                        //1. It contain a property of kind bag.
-                        //2. It contains a normal complex property 
-                        //with a sub property of kind bag.
-                        //The second case can be further expanded, i.e. 
-                        //if the normal complex property
-                        //has a normal complex sub property with a 
-                        //sub property of kind bag.
-                        //So for complex type we recursively call this 
-                        //function to check for bag.
-                        //Shown below how looping can happen in complex type:
-                        //Customer ResourceType (id1)
-                        //{
-                        //  ....
-                        //  Address: Address ResourceType (id2)
-                        //  {
-                        //    .....
-                        //    AltAddress: Address ResourceType (id2)
-                        //    {
-                        //      ...
-                        //    }
-                        //  }
-                        //}
-                        //
-                        //Here the resource type of Customer::Address and 
-                        //Customer::Address::AltAddress
-                        //are same, this is a loop, we need to detect 
-                        //this and avoid infinite recursive loop.
-                        //
-                        $count = count($arrayToDetectLoopInComplexType);
-                        $foundLoop = false;
-                        for ($i = 0; $i < $count; $i++) {
-                            if ($arrayToDetectLoopInComplexType[$i] === $resourceProperty->getResourceType()) {
-                                $foundLoop = true;
-                                break;
-                            }
-                        }
-
-                        if (!$foundLoop) {
-                            $arrayToDetectLoopInComplexType[$count] = $resourceProperty->getResourceType();
-                            $hasBagInComplex = $resourceProperty->getResourceType()->hasBagProperty($arrayToDetectLoopInComplexType);
-                            unset($arrayToDetectLoopInComplexType[$count]);
-                        }
-                    }
-
-                    if ($resourceProperty->isKindOf(ResourcePropertyKind::BAG) 
-                        || $hasBagInComplex
-                    ) {
-                        $this->_hasBagProperty = true;
-                        break;
-                    }
-                }
-            }
-        }
-        
-        return $this->_hasBagProperty;
-    }
-    
-    /** 
-     * Validate the type
-     * 
-     * @return void
-     * 
-     * @throws InvalidOperationException
-     */
-    public function validateType()
-    {
-        $keyProperties = $this->getKeyProperties();
-        if (($this->_resourceTypeKind == ResourceTypeKind::ENTITY) && empty($keyProperties)) {
-            throw new InvalidOperationException(
-                Messages::resourceTypeMissingKeyPropertiesForEntity(
-                    $this->getFullName()
-                )
-            );
-        }
-    }
-
-    /**     
-     * To check the type described by this resource type is assignable from 
-     * a type described by another resource type. Or this type is a sub-type 
-     * of (derived from the) given resource type
-     * 
-     * @param ResourceType $resourceType Another resource type.
-     * 
-     * @return boolean
-     */
-    public function isAssignableFrom(ResourceType $resourceType)
-    {        
-        $base = $this;
-        while ($base != null) {
-            if ($resourceType == $base) {
-                return true;
-            }
-            
-            $base = $base->_baseType;
-        }
-
-        return false;
-    }
-
-    /**     
-     * Get predefined ResourceType for a primitive type
-     *  
-     * @param EdmPrimitiveType $typeCode Typecode of primitive type
-     *
-     * @return ResourceType
-     * 
-     * @throws InvalidArgumentException
-     */
-    public static function getPrimitiveResourceType($typeCode)
-    {
-        switch($typeCode) {
-        case EdmPrimitiveType::BINARY:
-            return new ResourceType(
-                new Binary(), ResourceTypeKind::PRIMITIVE, 
-                'Binary', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::BOOLEAN:
-            return new ResourceType(
-                new Boolean(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Boolean', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::BYTE:
-            return new ResourceType(
-                new Byte(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Byte', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::DATETIME:
-            return new ResourceType(
-                new DateTime(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'DateTime', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::DECIMAL:
-            return new ResourceType(
-                new Decimal(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Decimal', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::DOUBLE:
-            return new ResourceType(
-                new Double(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Double', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::GUID:
-            return new ResourceType(
-                new Guid(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Guid', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::INT16:
-            return new ResourceType(
-                new Int16(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Int16', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::INT32:
-            return new ResourceType(
-                new Int32(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Int32', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::INT64:
-            return new ResourceType(
-                new Int64(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Int64', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::SBYTE:
-            return new ResourceType(
-                new SByte(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'SByte', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::SINGLE:
-            return new ResourceType(
-                new Single(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'Single', 'Edm'
-            );
-            break;
-        case EdmPrimitiveType::STRING:
-            return new ResourceType(
-                new String(), 
-                ResourceTypeKind::PRIMITIVE, 
-                'String', 'Edm'
-            );
-            break;
-        default:
-            throw new \InvalidArgumentException(
-                Messages::commonNotValidPrimitiveEDMType(
-                    '$typeCode', 'getPrimitiveResourceType'
-                )
-            );
-        }    
-    }
-}
-
+<?php
+/**
+ * A type to describe an entity type, complex type or primitive type
+ * 
+ * PHP version 5.3
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_Providers_Metadata
+ * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   SVN: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ * 
+ */
+namespace ODataProducer\Providers\Metadata;
+use ODataProducer\Providers\Metadata\Type\Binary;
+use ODataProducer\Providers\Metadata\Type\Boolean;
+use ODataProducer\Providers\Metadata\Type\Byte;
+use ODataProducer\Providers\Metadata\Type\DateTime;
+use ODataProducer\Providers\Metadata\Type\Decimal;
+use ODataProducer\Providers\Metadata\Type\Double;
+use ODataProducer\Providers\Metadata\Type\Guid;
+use ODataProducer\Providers\Metadata\Type\Int16;
+use ODataProducer\Providers\Metadata\Type\Int32;
+use ODataProducer\Providers\Metadata\Type\Int64;
+use ODataProducer\Providers\Metadata\Type\SByte;
+use ODataProducer\Providers\Metadata\Type\Single;
+use ODataProducer\Providers\Metadata\Type\String;
+use ODataProducer\Providers\Metadata\Type\TypeCode;
+use ODataProducer\Providers\Metadata\Type\EdmPrimitiveType;
+use ODataProducer\Providers\Metadata\Type\IType;
+use ODataProducer\Common\Messages;
+use ODataProducer\Common\InvalidOperationException;
+use ODataProducer\Common;
+/**
+ * A type to describe an entity type, complex type or primitive type.
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_Providers_Metadata
+ * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   Release: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ */
+class ResourceType
+{
+    /**
+     * Name of the resource described by this class instance.
+     * 
+     * @var string
+     */
+    private $_name;
+
+    /**
+     * Namespace name in which resource described by this class instance
+     * belongs to.
+     * 
+     * @var string
+     */
+    private $_namespaceName;
+
+    /**
+     * The fully qualified name of the resource described by this class instance.
+     * 
+     * @var string
+     */
+    private $_fullName;
+
+    /**
+     * The type the resource described by this class instance.
+     * Note: either Entity or Complex Type
+     * 
+     * @var  ResourceTypeKind
+     */
+    private $_resourceTypeKind;
+
+    /**
+     * @var boolean
+     */
+    private $_abstractType;
+
+    /**
+     * Refrence to ResourceType instance for base type, if any.
+     * 
+     * @var ResourceType
+     */
+    private $_baseType;
+
+    /** 
+     * Collection of ResourceProperty for all properties declared on the
+     * resource described by this class instance (This does not include 
+     * base type properties).
+     * 
+     * @var array(string, ResourceProperty)
+     */
+    private $_propertiesDeclaredOnThisType = array();
+
+    /**
+     * Collection of ResourceStreamInfo for all named streams declared on 
+     * the resource described by this class instance (This does not include 
+     * base type properties).
+     * 
+     * @var array(string, ResourceStreamInfo)
+     */
+    private $_namedStreamsDeclaredOnThisType = array();
+
+    /**
+     * Collection of ReflectionProperty instances for each property declared 
+     * on this type
+     * 
+     * @var array(ResourceProperty, ReflectionProperty)
+     */
+    private $_propertyInfosDeclaredOnThisType = array();
+
+    /**
+     * Collection of ResourceProperty for all properties declared on this type.
+     * and base types.
+     * 
+     * @var array(string, ResourceProperty)
+     */    
+    private $_allProperties = array();
+
+    /**
+     * Collection of ResourceStreamInfo for all named streams declared on this type.
+     * and base types
+     * 
+     * @var array(string, ResourceStreamInfo)
+     */
+    private $_allNamedStreams = array();
+
+    /**      
+     * Collection of properies which has etag defined subeset of $_allProperies
+     * @var array(ResourceProperty)
+     */
+    private $_etagProperties = array();
+
+    /** 
+     * Collection of key properies subeset of $_allProperies
+     * 
+     * @var array(ResourceProperty)
+     */
+    private $_keyProperties = array();
+
+    /**      
+     * Whether the resource type described by this class intance is a MLE or not
+     * 
+     * @var boolean
+     */
+    private $_isMediaLinkEntry = false;
+
+    /**
+     * Whether the resource type described by this class instance has bag properties
+     * Note: This has been intitialized with null, later in hasBagProperty method, 
+     * this flag will be set to boolean value
+     * 
+     * @var boolean
+     */
+    private $_hasBagProperty = null;
+
+    /**
+     * Whether the resource type described by this class instance has named streams
+     * Note: This has been intitialized with null, later in hasNamedStreams method, 
+     * this flag will be set to boolean value
+     * 
+     * @var boolean
+     */
+    private $_hasNamedStreams = null;
+
+    /**     
+     * ReflectionClass (for complex/Entity) or IType (for Primitive) instance for 
+     * the resource (type) described by this class intstance
+     * 
+     * @var ReflectionClass/IType
+     */
+    private $_type;
+
+    /**
+     * To store any custom information related to this class intstance
+     * 
+     * @var Object
+     */
+    private $_customState; 
+
+    /**
+     * Array to detect looping in bag's complex type  
+     * 
+     * @var array(mixed)
+     */
+    private $_arrayToDetectLoopInComplexBag;
+
+    /**
+     * Create new instance of ResourceType
+     * 
+     * @param ReflectionClass/IType $instanceType     Instance type for the resource,
+     *                                                for entity and 
+     *                                                complex this will 
+     *                                                be 'ReflectionClass' and for 
+     *                                                primitive type this 
+     *                                                will be IType
+     * @param ResourceTypeKind      $resourceTypeKind Kind of resource 
+     *                                               (Entity, Complex or Primitive)
+     * @param string                $name             Name of the resource
+     * @param string                $namespaceName    Namespace of the resource
+     * @param ResourceType          $baseType         Base type of the 
+     *                                                resource, if exists 
+     * @param boolean               $isAbstract       Whether resource is abstract
+     * 
+     * @throws InvalidArgumentException
+     */
+    public function __construct($instanceType, $resourceTypeKind, $name, 
+        $namespaceName = null, ResourceType $baseType = null, 
+        $isAbstract = false
+    ) {
+        $this->_type = $instanceType;
+        if ($resourceTypeKind == ResourceTypeKind::PRIMITIVE) {
+            if ($baseType != null) {
+                throw new \InvalidArgumentException(
+                    Messages::resourceTypeNoBaseTypeForPrimitive()
+                );
+            }
+
+            if ($isAbstract) {
+                throw new \InvalidArgumentException(
+                    Messages::resourceTypeNoAbstractForPrimitive()
+                );
+            }
+
+            if (!($instanceType instanceof IType)) {
+                throw new \InvalidArgumentException(
+                    Messages::resourceTypeTypeShouldImplementIType('$instanceType')
+                );
+            }
+        } else {
+            if (!($instanceType instanceof \ReflectionClass)) {
+                throw new \InvalidArgumentException(
+                    Messages::resourceTypeTypeShouldReflectionClass('$instanceType')
+                );
+            }
+        }
+
+        $this->_resourceTypeKind = $resourceTypeKind;
+        $this->_name = $name;
+        $this->_baseType = $baseType;        
+        $this->_namespaceName = $namespaceName; 
+        $this->_fullName 
+            = is_null($namespaceName) ? $name : $namespaceName . '.' . $name;
+        $this->_abstractType = $isAbstract;
+        $this->_isMediaLinkEntry = false;
+        $this->_customState = null;
+        $this->_arrayToDetectLoopInComplexBag = array();
+        //TODO: Set MLE if base type has MLE Set
+    }
+
+    /**
+     * Get reference to ResourceType for base class
+     * 
+     * @return ResourceType
+     */
+    public function getBaseType()
+    {
+        return $this->_baseType;
+    }
+
+    /**
+     * To check whether this resource type has base type
+     * 
+     * @return boolean True if base type is defined, false otherwise
+     */
+    public function hasBaseType()
+    {
+        return !is_null($this->_baseType);
+    }
+
+    /**
+     * To get custom state object for this type
+     * 
+     * @return Object
+     */
+    public function getCustomState()
+    {
+        return $this->_customState;
+    }
+
+    /**
+     * To set custom state object for this type
+     * 
+     * @param Object $object The custom object.
+     * 
+     * @return void
+     */
+    public function setCustomState($object)
+    {
+        $this->_customState = $object;
+    }
+
+    /**
+     * Get the instance type. If the resource type describes a complex or entity type
+     * then this function returns refernece to ReflectionClass instance for the type.
+     * If resource type describes a primitive type then this function returns ITYpe.
+     * 
+     * @return ReflectionClass/IType
+     */
+    public function getInstanceType()
+    {
+        return $this->_type;
+    }
+
+    /**
+     * Get name of the type described by this resource type
+     * 
+     * @return string
+     */
+    public function getName()
+    {
+        return $this->_name;
+    }
+
+    /**
+     * Get the namespace under which the type described by this resource type is
+     * defined.
+     * 
+     * @return string
+     */
+    public function getNamespace()
+    {
+        return $this->_namespaceName;
+    }
+
+    /**
+     * Get full name (namespacename.typename) of the type described by this resource 
+     * type.
+     * 
+     * @return string
+     */
+    public function getFullName()
+    {
+        return $this->_fullName;
+    }
+
+    /**
+     * To check whether the type described by this resource type is abstract or not
+     * 
+     * @return boolean True if type is abstract else False
+     */
+    public function isAbstract()
+    {
+        return $this->_abstractType;
+    }
+
+    /**
+     * To get the kind of type described by this resource class
+     * 
+     * @return ResourceTypeKind
+     */
+    public function getResourceTypeKind()
+    {
+        return $this->_resourceTypeKind;
+    }
+
+    /**
+     * To check whether the type described by this resource type is MLE
+     * 
+     * @return boolean True if type is MLE else False
+     */
+    public function isMediaLinkEntry()
+    {
+        return $this->_isMediaLinkEntry;
+    }
+
+    /**
+     * Set the resource type as MLE or non-MLE
+     * 
+     * @param boolean $isMLE True to set as MLE, false for non-MLE
+     * 
+     * @return void
+     */
+    public function setMediaLinkEntry($isMLE)
+    {
+        if ($this->_resourceTypeKind != ResourceTypeKind::ENTITY) {
+            throw new InvalidOperationException(
+                Messages::resourceTypeHasStreamAttributeOnlyAppliesToEntityType()
+            );
+        }
+
+        $this->_isMediaLinkEntry = $isMLE;
+    }
+
+    /**      
+     * Add a property belongs to this resource type instance
+     * 
+     * @param ResourceProperty $property Property to add
+     * 
+     * @throws InvalidOperationException
+     * @return void
+     */
+    public function addProperty(ResourceProperty $property)
+    {
+        if ($this->_resourceTypeKind == ResourceTypeKind::PRIMITIVE) {
+            throw new InvalidOperationException(
+                Messages::resourceTypeNoAddPropertyForPrimitive()
+            );
+        }
+
+        $name = $property->getName();
+        foreach (array_keys($this->_propertiesDeclaredOnThisType) as $propertyName) {
+            if (strcasecmp($propertyName, $name) == 0) {
+                throw new InvalidOperationException(
+                    Messages::resourceTypePropertyWithSameNameAlreadyExists(
+                        $propertyName, $this->_name
+                    )
+                );
+            }
+        }
+
+        if ($property->isKindOf(ResourcePropertyKind::KEY)) {
+            if ($this->_resourceTypeKind != ResourceTypeKind::ENTITY) {
+                throw new InvalidOperationException(
+                    Messages::resourceTypeKeyPropertiesOnlyOnEntityTypes()
+                );
+            }
+
+            if ($this->_baseType != null) {
+                throw new InvalidOperationException(
+                    Messages::resourceTypeNoKeysInDerivedTypes()
+                );
+            }
+        }
+
+        if ($property->isKindOf(ResourcePropertyKind::ETAG) 
+            && ($this->_resourceTypeKind != ResourceTypeKind::ENTITY)
+        ) {
+            throw new InvalidOperationException(
+                Messages::resourceTypeETagPropertiesOnlyOnEntityTypes()
+            );
+        }
+
+        //Check for Base class properties
+        $this->_propertiesDeclaredOnThisType[$name] = $property;
+        // Set $this->_allProperties to null, this is very important because the 
+        // first call to getAllProperties will initilaize $this->_allProperties, 
+        // further call to getAllProperties will not reinitialize _allProperties
+        // so if addProperty is called after calling getAllProperties then the 
+        // property just added will not be reflected in $this->_allProperties
+        unset($this->_allProperties);
+        $this->_allProperties = array();
+    }
+
+    /**
+     * Get collection properties belongs to this resource type (excluding base class
+     * properties). This function returns  empty array in case of resource type
+     * for primitive types.
+     * 
+     * @return array(name, ResourceProperty)
+     */
+    public function getPropertiesDeclaredOnThisType()
+    {
+        return $this->_propertiesDeclaredOnThisType;
+    }
+
+    /**
+     * Get collection properties belongs to this resource type including base class
+     * properties. This function returns  empty array in case of resource type
+     * for primitive types.
+     * 
+     * @return array(name, ResourceProperty)
+     */
+    public function getAllProperties()
+    {
+        if (empty($this->_allProperties)) {
+            if ($this->_baseType != null) {
+                $this->_allProperties = $this->_baseType->getAllProperties();
+            }
+
+            $this->_allProperties = array_merge(
+                $this->_allProperties, $this->_propertiesDeclaredOnThisType
+            );
+        }
+
+        return $this->_allProperties;
+    }
+
+    /**     
+     * Get collection key properties belongs to this resource type. This 
+     * function returns non-empty array only for resource type representing 
+     * an entity type.
+     *  
+     * @return array(name, ResourceProperty)
+     */
+    public function getKeyProperties()
+    {
+        if (empty($this->_keyProperties)) {
+            $baseType = $this;
+            while ($baseType->_baseType != null) {
+                $baseType = $baseType->_baseType;
+            }
+
+            foreach ($baseType->_propertiesDeclaredOnThisType 
+                as $propertyName => $resourceProperty
+            ) {
+                if ($resourceProperty->isKindOf(ResourcePropertyKind::KEY)) {
+                    $this->_keyProperties[$propertyName] = $resourceProperty;
+                }
+            }
+        }
+
+        return $this->_keyProperties;
+    }
+
+    /**
+     * Get collection of e-tag properties belongs to this type.
+     * 
+     * @return array(name, ResourceProperty)
+     */
+    public function getETagProperties()
+    {
+        if (empty ($this->_etagProperties)) {
+            foreach ($this->getAllProperties() 
+                as $propertyName => $resourceProperty
+            ) {
+                if ($resourceProperty->isKindOf(ResourcePropertyKind::ETAG)) {
+                    $this->_etagProperties[$propertyName] = $resourceProperty;
+                }
+            }
+        }
+
+        return $this->_etagProperties;
+    }
+
+    /**
+     * To check this type has any eTag properties
+     * 
+     * @return boolean
+     */
+    public function hasETagProperties()
+    {
+        $this->getETagProperties();
+        return !empty($this->_etagProperties);
+    }
+
+    /**
+     * Try to get ResourceProperty for a property defined for this resource type
+     * excluding base class properties
+     * 
+     * @param string $propertyName The name of the property to resolve.
+     * 
+     * @return ResourceProperty or NULL
+     */
+    public function tryResolvePropertyTypeDeclaredOnThisTypeByName($propertyName)
+    {
+        if (array_key_exists($propertyName, $this->_propertiesDeclaredOnThisType)) {
+            return $this->_propertiesDeclaredOnThisType[$propertyName];
+        }
+
+        return null;
+    }
+
+    /** 
+     * Try to get ResourceProperty for a property defined for this resource type
+     * including base class properties
+     * 
+     * @param string $propertyName The name of the property to resolve.
+     * 
+     * @return ResourceProperty or NULL
+     */
+    public function tryResolvePropertyTypeByName($propertyName)
+    {
+        if (array_key_exists($propertyName, $this->getAllProperties())) {
+            return $this->_allProperties[$propertyName];
+        }
+
+        return null;
+    }
+
+    /**
+     * Add a named stream belongs to this resource type instance
+     * 
+     * @param ResourceStreamInfo $namedStream ResourceStreamInfo instance describing
+     *                                        the named stream to add.
+     * 
+     * @return void
+     * 
+     * @throws InvalidOperationException
+     */
+    public function addNamedStream(ResourceStreamInfo $namedStream)
+    {
+        if ($this->_resourceTypeKind != ResourceTypeKind::ENTITY) {
+            throw new InvalidOperationException(
+                Messages::resourceTypeNamedStreamsOnlyApplyToEntityType()
+            );
+        }
+
+        $name = $namedStream->getName();
+        foreach (array_keys($this->_namedStreamsDeclaredOnThisType) 
+            as $namedStreamName
+        ) {
+            if (strcasecmp($namedStreamName, $name) == 0) {
+                throw new InvalidOperationException(
+                    Messages::resourceTypeNamedStreamWithSameNameAlreadyExists(
+                        $name, $this->_name
+                    )
+                );
+            }
+        }
+
+        $this->_namedStreamsDeclaredOnThisType[$name] = $namedStream;
+        // Set $this->_allNamedStreams to null, the first call to getAllNamedStreams
+        // will initilaize $this->_allNamedStreams, further call to 
+        // getAllNamedStreams will not reinitialize _allNamedStreams
+        // so if addNamedStream is called after calling getAllNamedStreams then the
+        // property just added will not be reflected in $this->_allNamedStreams
+        unset($this->_allNamedStreams);
+        $this->_allNamedStreams = array();
+    }
+
+    /**
+     * Get collection of ResourceStreamInfo describing the named streams belongs 
+     * to this resource type (excluding base class properties)
+     * 
+     * @return array(name, ResourceStreamInfo)
+     */
+    public function getNamedStreamsDeclaredOnThisType()
+    {
+        return $this->_namedStreamsDeclaredOnThisType;
+    }
+
+    /**
+     * Get collection of ResourceStreamInfo describing the named streams belongs 
+     * to this resource type including base class named streams.
+     * 
+     * @return array(name, ResourceStreamInfo)
+     */
+    public function getAllNamedStreams()
+    {
+        if (empty($this->_allNamedStreams)) {
+            if ($this->_baseType != null) {
+                $this->_allNamedStreams = $this->_baseType->getAllNamedStreams();
+            }
+
+            $this->_allNamedStreams 
+                = array_merge(
+                    $this->_allNamedStreams, 
+                    $this->_namedStreamsDeclaredOnThisType
+                );
+        }
+
+        return $this->_allNamedStreams;
+    }
+
+    /** 
+     * Try to get ResourceStreamInfo for a named stream defined for this
+     * resource type excluding base class named streams
+     * 
+     * @param string $namedStreamName Name of the named stream to resolve.
+     * 
+     * @return ResourceStreamInfo or NULL
+     */
+    public function tryResolveNamedStreamDeclaredOnThisTypeByName($namedStreamName)
+    {
+        if (array_key_exists($namedStreamName, $this->_namedStreamsDeclaredOnThisType)) {
+            return $this->_namedStreamsDeclaredOnThisType[$namedStreamName];
+        }
+
+        return null;
+    }
+
+    /** 
+     * Try to get ResourceStreamInfo for a named stream defined for this resource 
+     * type including base class named streams
+     * 
+     * @param string $namedStreamName Name of the named stream to resolve.
+     * 
+     * @return ResourceStreamInfo or NULL
+     */
+    public function tryResolveNamedStreamByName($namedStreamName)
+    {
+        if (array_key_exists($namedStreamName, $this->getAllNamedStreams())) {
+            return $this->_allNamedStreams[$namedStreamName];
+        }
+
+        return null;
+    }
+
+    /**
+     * Check this resource type instance has named stream associated with it
+     * Note: This is an internal method used by library. Devs don't use this.
+     * 
+     * @return boolean true if resource type instance has named stream else false
+     */
+    public function hasNamedStream()
+    {   
+        // Note: Calling this method will initialize _allNamedStreams 
+        // and _hasNamedStreams flag to a boolean value
+        // from null depending on the current state of _allNamedStreams 
+        // array, so method should be called only after adding all 
+        // named streams
+        if (is_null($this->_hasNamedStreams)) {
+            $this->getAllNamedStreams();
+            $this->_hasNamedStreams = !empty($this->_allNamedStreams);
+        }
+        
+        return $this->_hasNamedStreams;
+    }
+
+    /**
+     * Check this resource type instance has bag property associated with it
+     * Note: This is an internal method used by library. Devs don't use this.
+     * 
+     * @param array(mixed) &$arrayToDetectLoopInComplexType array for detecting loop.
+     * 
+     * @return boolean true if resource type instance has bag property else false
+     */
+    public function hasBagProperty(&$arrayToDetectLoopInComplexType)
+    {        
+        // Note: Calling this method will initialize _bagProperties 
+        // and _hasBagProperty flag to a boolean value
+        // from null depending on the current state of 
+        // _propertiesDeclaredOnThisType array, so method
+        // should be called only after adding all properties
+        if (is_null($this->_hasBagProperty)) {
+            if ($this->_baseType != null 
+                && $this->_baseType->hasBagProperty($arrayToDetectLoopInComplexType)
+            ) {
+                        $this->_hasBagProperty = true;
+            } else {
+                foreach ($this->_propertiesDeclaredOnThisType as $resourceProperty) {
+                    $hasBagInComplex = false;
+                    if ($resourceProperty->isKindOf(ResourcePropertyKind::COMPLEX_TYPE)) {
+                        //We can say current ResouceType ("this") 
+                        //is contains a bag property if:
+                        //1. It contain a property of kind bag.
+                        //2. It contains a normal complex property 
+                        //with a sub property of kind bag.
+                        //The second case can be further expanded, i.e. 
+                        //if the normal complex property
+                        //has a normal complex sub property with a 
+                        //sub property of kind bag.
+                        //So for complex type we recursively call this 
+                        //function to check for bag.
+                        //Shown below how looping can happen in complex type:
+                        //Customer ResourceType (id1)
+                        //{
+                        //  ....
+                        //  Address: Address ResourceType (id2)
+                        //  {
+                        //    .....
+                        //    AltAddress: Address ResourceType (id2)
+                        //    {
+                        //      ...
+                        //    }
+                        //  }
+                        //}
+                        //
+                        //Here the resource type of Customer::Address and 
+                        //Customer::Address::AltAddress
+                        //are same, this is a loop, we need to detect 
+                        //this and avoid infinite recursive loop.
+                        //
+                        $count = count($arrayToDetectLoopInComplexType);
+                        $foundLoop = false;
+                        for ($i = 0; $i < $count; $i++) {
+                            if ($arrayToDetectLoopInComplexType[$i] === $resourceProperty->getResourceType()) {
+                                $foundLoop = true;
+                                break;
+                            }
+                        }
+
+                        if (!$foundLoop) {
+                            $arrayToDetectLoopInComplexType[$count] = $resourceProperty->getResourceType();
+                            $hasBagInComplex = $resourceProperty->getResourceType()->hasBagProperty($arrayToDetectLoopInComplexType);
+                            unset($arrayToDetectLoopInComplexType[$count]);
+                        }
+                    }
+
+                    if ($resourceProperty->isKindOf(ResourcePropertyKind::BAG) 
+                        || $hasBagInComplex
+                    ) {
+                        $this->_hasBagProperty = true;
+                        break;
+                    }
+                }
+            }
+        }
+        
+        return $this->_hasBagProperty;
+    }
+    
+    /** 
+     * Validate the type
+     * 
+     * @return void
+     * 
+     * @throws InvalidOperationException
+     */
+    public function validateType()
+    {
+        $keyProperties = $this->getKeyProperties();
+        if (($this->_resourceTypeKind == ResourceTypeKind::ENTITY) && empty($keyProperties)) {
+            throw new InvalidOperationException(
+                Messages::resourceTypeMissingKeyPropertiesForEntity(
+                    $this->getFullName()
+                )
+            );
+        }
+    }
+
+    /**     
+     * To check the type described by this resource type is assignable from 
+     * a type described by another resource type. Or this type is a sub-type 
+     * of (derived from the) given resource type
+     * 
+     * @param ResourceType $resourceType Another resource type.
+     * 
+     * @return boolean
+     */
+    public function isAssignableFrom(ResourceType $resourceType)
+    {        
+        $base = $this;
+        while ($base != null) {
+            if ($resourceType == $base) {
+                return true;
+            }
+            
+            $base = $base->_baseType;
+        }
+
+        return false;
+    }
+
+    /**     
+     * Get predefined ResourceType for a primitive type
+     *  
+     * @param EdmPrimitiveType $typeCode Typecode of primitive type
+     *
+     * @return ResourceType
+     * 
+     * @throws InvalidArgumentException
+     */
+    public static function getPrimitiveResourceType($typeCode)
+    {
+        switch($typeCode) {
+        case EdmPrimitiveType::BINARY:
+            return new ResourceType(
+                new Binary(), ResourceTypeKind::PRIMITIVE, 
+                'Binary', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::BOOLEAN:
+            return new ResourceType(
+                new Boolean(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Boolean', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::BYTE:
+            return new ResourceType(
+                new Byte(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Byte', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::DATETIME:
+            return new ResourceType(
+                new DateTime(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'DateTime', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::DECIMAL:
+            return new ResourceType(
+                new Decimal(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Decimal', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::DOUBLE:
+            return new ResourceType(
+                new Double(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Double', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::GUID:
+            return new ResourceType(
+                new Guid(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Guid', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::INT16:
+            return new ResourceType(
+                new Int16(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Int16', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::INT32:
+            return new ResourceType(
+                new Int32(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Int32', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::INT64:
+            return new ResourceType(
+                new Int64(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Int64', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::SBYTE:
+            return new ResourceType(
+                new SByte(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'SByte', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::SINGLE:
+            return new ResourceType(
+                new Single(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'Single', 'Edm'
+            );
+            break;
+        case EdmPrimitiveType::STRING:
+            return new ResourceType(
+                new String(), 
+                ResourceTypeKind::PRIMITIVE, 
+                'String', 'Edm'
+            );
+            break;
+        default:
+            throw new \InvalidArgumentException(
+                Messages::commonNotValidPrimitiveEDMType(
+                    '$typeCode', 'getPrimitiveResourceType'
+                )
+            );
+        }    
+    }
+}
+
 ?>
\ No newline at end of file
Index: library/ODataProducer/Providers/Metadata/ServiceBaseMetadata.php
===================================================================
--- library/ODataProducer/Providers/Metadata/ServiceBaseMetadata.php	(revision 2307)
+++ library/ODataProducer/Providers/Metadata/ServiceBaseMetadata.php	(working copy)
@@ -1,521 +1,521 @@
-<?php
-/** 
- * Implementation of IDataServiceMetadataProvider.
- * 
- * PHP version 5.3
- * 
- * @category  Providers
- * @package   ServiceBaseMetadata
- * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   SVN: 1.0
- * @link      http://odataphpproducer.codeplex.com
- * 
- */
-namespace ODataProducer\Providers\Metadata;
-use ODataProducer\Providers\Metadata\ResourceStreamInfo;
-use ODataProducer\Providers\Metadata\ResourceAssociationSetEnd;
-use ODataProducer\Providers\Metadata\ResourceAssociationSet;
-use ODataProducer\Common\NotImplementedException;
-use ODataProducer\Providers\Metadata\Type\EdmPrimitiveType;
-use ODataProducer\Providers\Metadata\ResourceSet;
-use ODataProducer\Providers\Metadata\ResourcePropertyKind;
-use ODataProducer\Providers\Metadata\ResourceProperty;
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Metadata'.DIRECTORY_SEPARATOR.'ResourceTypeKind.php';
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Metadata'.DIRECTORY_SEPARATOR.'ResourceType.php';
-use ODataProducer\Common\InvalidOperationException;
-use ODataProducer\Providers\Metadata\IDataServiceMetadataProvider;
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Metadata'.DIRECTORY_SEPARATOR.'IDataServiceMetadataProvider.php';
-
-/**
- * Custom IDataServiceMetadata implementation
- * 
- * @category  Providers
- * @package   ServiceBaseMetadata
- * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http:'.DIRECTORY_SEPARATOR.'/www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   Release: 1.0
- * @link      http://odataphpproducer.codeplex.com
- */
-class ServiceBaseMetadata implements IDataServiceMetadataProvider
-{
-    protected $resourceSets = array();
-    protected $resourceTypes = array();
-    protected $associationSets = array();
-    protected $containerName;
-    protected $namespaceName;
-    
-    //Begin Implementation of IDataServiceMetadataProvider
-    /**
-     * get the Container name for the data source.
-     * 
-     * @return String container name
-     */
-    public function getContainerName()
-    {
-        return $this->containerName;
-    }
-    
-    /**
-     * get Namespace name for the data source.
-     * 
-     * @return String namespace
-     */
-    public function getContainerNamespace()
-    {
-        return $this->namespaceName;
-    }
-    
-    /**
-     * get all entity set information.
-     * 
-     * @return array(ResourceSet)
-     */
-    public function getResourceSets()
-    {
-        return array_values($this->resourceSets);
-    }
-    
-    /**
-     * get all resource types in the data source.
-     * 
-     * @return array(ResourceType)
-     */
-    public function getTypes()
-    {
-        return array_values($this->resourceTypes);
-    }
-    
-    /**
-     * get a resource set based on the specified resource set name.
-     * 
-     * @param string $name Name of the resource set
-     * 
-     * @return ResourceSet/NULL resource set with the given name if found 
-     *                          else NULL
-     */
-    public function resolveResourceSet($name)
-    {
-        if (array_key_exists($name, $this->resourceSets)) {
-            return $this->resourceSets[$name];
-        }
-        
-        return null;
-    }
-    
-    /**
-     * get a resource type based on the resource set name.
-     * 
-     * @param string $name Name of the resource set
-     * 
-     * @return ResourceType/NULL resource type with the given resource set
-     *                           name if found else NULL
-     */
-    public function resolveResourceType($name)
-    {
-        if (array_key_exists($name, $this->resourceTypes)) {
-            return $this->resourceTypes[$name];
-        }
-        
-        return null;
-    }
-    
-    /**
-     * The method must return a collection of all the types derived from 
-     * $resourceType The collection returned should NOT include the type 
-     * passed in as a parameter An implementer of the interface should 
-     * return null if the type does not have any derived types.
-     * 
-     * @param ResourceType $resourceType Resource to get derived resource 
-     *                                   types from
-     * 
-     * @return array(ResourceType)/NULL
-     */
-    public function getDerivedTypes(ResourceType $resourceType)
-    {
-        return null;
-    }
-    
-    /**
-     * Returns true if $resourceType represents an Entity Type which has derived
-     *                               Entity Types, else false.
-     * 
-     * @param ResourceType $resourceType Resource to check for derived resource 
-     *                                   types.
-     * 
-     * @return boolean
-     */
-    public function hasDerivedTypes(ResourceType $resourceType)
-    {
-        return false;
-    }
-    
-    /**
-     * Gets the ResourceAssociationSet instance for the given source 
-     * association end.
-     * 
-     * @param ResourceSet      $sourceResourceSet      Resource set 
-     *                                                 of the source
-     *                                                 association end
-     * @param ResourceType     $sourceResourceType     Resource type of the source
-     *                                                 association end
-     * @param ResourceProperty $targetResourceProperty Resource property of 
-     *                                                 the source
-     *                                                 association end
-     * 
-     * @return ResourceAssociationSet
-     */
-    public function getResourceAssociationSet(ResourceSet $sourceResourceSet, ResourceType $sourceResourceType, ResourceProperty $targetResourceProperty)
-    {
-        //e.g.
-        //ResourceSet => Representing 'Customers' entity set
-        //ResourceType => Representing'Customer' entity type
-        //ResourceProperty => Representing 'Orders' property
-        //We have created ResourceAssoicationSet while adding 
-        //ResourceSetReference or ResourceReference
-        //and kept in $this->associationSets
-        //$metadata->addResourceSetReferenceProperty(
-        //             $customersEntityType, 
-        //             'Orders', 
-        //             $ordersResourceSet
-        //             );
-        
-        $targetResourceSet = $targetResourceProperty->getResourceType()->getCustomState();
-        if (is_null($targetResourceSet)) {
-            throw new InvalidOperationException('Failed to retrieve the custom state from ' . $resourceProperty->getResourceType()->getName());
-        }
-
-        //Customer_Orders_Orders, Order_Customer_Customers
-        $key = $sourceResourceType->getName() . '_' . $targetResourceProperty->getName() . '_' . $targetResourceSet->getName();
-        if (array_key_exists($key, $this->associationSets)) {
-            return $this->associationSets[$key];
-        }
-
-        return null;
-    }
-
-    //End Implementation of IDataServiceMetadataProvider
-    
-    /** 
-     * Construct new instance of NorthWindMetadata
-     * 
-     * @param string $containerName container name for the datasource.
-     * @param string $namespaceName namespace for the datasource.
-     * 
-     * @return void
-     */
-    public function __construct($containerName, $namespaceName)
-    {
-        $this->containerName = $containerName;
-        $this->namespaceName = $namespaceName;
-    }
-    
-    /**
-     * Add an entity type
-     * 
-     * @param ReflectionClass $refClass  reflection class of the entity
-     * @param string          $name      name of the entity
-     * @param string          $namespace namespace of the datasource
-     * 
-     * @return ResourceType
-     */
-    public function addEntityType($refClass, $name, $namespace=null)
-    {
-        if (array_key_exists($name, $this->resourceTypes)) {
-            throw new InvalidOperationException('Type with same name already added');
-        }
-        
-        $entityType = new ResourceType($refClass, ResourceTypeKind::ENTITY, $name, $namespace);
-        $this->resourceTypes[$name] = $entityType;
-        return $entityType;
-    }
-    
-    /**
-     * Add a complex type
-     * 
-     * @param ReflectionClass $refClass         reflection class of the 
-     *                                          complex entity type
-     * @param string          $name             name of the entity
-     * @param string          $namespace        namespace of the datasource.
-     * @param ResourceType    $baseResourceType base resource type
-     * 
-     * @return ResourceType
-     */
-    public function addComplexType($refClass, $name, $namespace=null, $baseResourceType = null)
-    {
-        if (array_key_exists($name, $this->resourceTypes)) {
-            throw new InvalidOperationException('Type with same name already added');
-        }
-        
-        $complexType = new ResourceType($refClass, ResourceTypeKind::COMPLEX, $name, $namespace, $baseResourceType);    	
-        $this->resourceTypes[$name] = $complexType;
-        return $complexType;
-    }
-    
-    /**
-     * Add a resouce set
-     * 
-     * @param string      $name         name of the resource set
-     * @param ResouceType $resourceType resource type
-     * 
-     * @throws InvalidOperationException
-     * 
-     * @return ResourceSet
-     */
-    public function addResourceSet($name, $resourceType)
-    {
-        if (array_key_exists($name, $this->resourceSets)) {
-            throw new InvalidOperationException('Resource Set already added');
-        }
-        
-        $this->resourceSets[$name] = new ResourceSet($name, $resourceType);
-        //No support for multiple ResourceSet with same EntityType
-        //So keeping reference to the 'ResourceSet' with the entity type
-        $resourceType->setCustomState($this->resourceSets[$name]);
-        return $this->resourceSets[$name];
-    }
-    
-    /**
-     * To add a Key-primitive property to a resouce (Complex/Entuty)
-     * 
-     * @param ResourceType $resourceType resource type to which key property
-     *                                   is to be added
-     * @param string       $name         name of the key property
-     * @param TypeCode     $typeCode     type of the key property
-     * 
-     * @return void
-     */
-    public function addKeyProperty($resourceType, $name, $typeCode)
-    {
-        $this->_addPrimitivePropertyInternal($resourceType, $name, $typeCode, true);
-    }
-    
-    /**
-     * To add a NonKey-primitive property (Complex/Entity)
-     * 
-     * @param ResourceType $resourceType resource type to which key property
-     *                                   is to be added
-     * @param string       $name         name of the key property
-     * @param TypeCode     $typeCode     type of the key property
-     * @param Boolean      $isBag        property is bag or not
-     * 
-     * @return void
-     */
-    public function addPrimitiveProperty($resourceType, $name, $typeCode, $isBag = false)
-    {
-        $this->_addPrimitivePropertyInternal($resourceType, $name, $typeCode, false, $isBag);
-    }
-
-    /**
-     * To add a non-key etag property
-     * 
-     * @param ResourceType $resourceType resource type to which key property
-     *                                   is to be added
-     * @param String       $name         name of the property
-     * @param String       $typeCode     type of the etag property
-     * 
-     * @return void
-     */
-    public function addETagProperty($resourceType, $name, $typeCode)
-    {
-        $this->_addPrimitivePropertyInternal($resourceType, $name, $typeCode, false, false, true);
-    }
-
-    /**
-     * To add a resource reference property
-     * 
-     * @param ResourceType $resourceType      The resource type to add the resource
-     *                                        reference property to
-     * @param string       $name              The name of the property to add
-     * @param ResourceSet  $targetResourceSet The resource set the resource reference
-     *                                        property points to
-     *                    
-     * @return void                  
-     */
-    public function addResourceReferenceProperty($resourceType, $name, $targetResourceSet)
-    {
-        $this->_addReferencePropertyInternal(
-            $resourceType, 
-            $name, 
-            $targetResourceSet,
-            ResourcePropertyKind::RESOURCE_REFERENCE
-        );
-    }
-
-    /**
-     * To add a resource set reference property
-     *      
-     * @param ResourceType $resourceType      The resource type to add the 
-     *                                        resource reference set property to
-     * @param string       $name              The name of the property to add
-     * @param ResourceSet  $targetResourceSet The resource set the resource 
-     *                                        reference set property points to
-     *                                        
-     * @return void                                      
-     */
-    public function addResourceSetReferenceProperty($resourceType, $name, $targetResourceSet)
-    {
-        $this->_addReferencePropertyInternal(
-            $resourceType, 
-            $name, 
-            $targetResourceSet,
-            ResourcePropertyKind::RESOURCESET_REFERENCE
-        );
-    }
-    
-    /**
-     * To add a complex property to entity or complex type
-     * 
-     * @param ResourceType $resourceType        The resource type to which the 
-     *                                          complex property needs to add
-     * @param string       $name                name of the complex property
-     * @param ResourceType $complexResourceType complex resource type
-     * @param Boolean      $isBag               complex type is bag or not
-     * 
-     * @return ResourceProperty
-     */
-    public function addComplexProperty($resourceType, $name, $complexResourceType, $isBag = false)
-    {
-        if ($resourceType->getResourceTypeKind() != ResourceTypeKind::ENTITY 
-            && $resourceType->getResourceTypeKind() != ResourceTypeKind::COMPLEX
-        ) {
-            throw new InvalidOperationException('complex property can be added to an entity or another complex type');
-        }
-        
-        try 
-        {
-            $resourceType->getInstanceType()->getProperty($name);
-        }
-        catch (ReflectionException $ex)
-        {
-            throw new InvalidOperationException(
-                'Can\'t add a property which does not exist on the instance type.'
-            );
-        }
-
-        $kind = ResourcePropertyKind::COMPLEX_TYPE;
-        if ($isBag) {    	   
-            $kind = $kind | ResourcePropertyKind::BAG;
-        }
-
-        $resourceProperty = new ResourceProperty($name, null, $kind, $complexResourceType);
-        $resourceType->addProperty($resourceProperty);
-        return $resourceProperty;
-    }
-    
-    /**
-     * To add a Key/NonKey-primitive property to a resource (complex/entity)
-     * 
-     * @param ResourceType $resourceType   Resource type
-     * @param string       $name           name of the property
-     * @param TypeCode     $typeCode       type of property
-     * @param boolean      $isKey          property is key or not
-     * @param boolean      $isBag          property is bag or not
-     * @param boolean      $isETagProperty property is etag or not
-     * 
-     * @return void
-     */
-    private function _addPrimitivePropertyInternal($resourceType, $name, $typeCode, $isKey = false, $isBag = false, $isETagProperty = false)
-    {
-        try 
-        {
-            $resourceType->getInstanceType()->getProperty($name);
-        }
-        catch (ReflectionException $ex)
-        {
-            throw new InvalidOperationException(
-                'Can\'t add a property which does not exist on the instance type.'
-            );
-        }
-        
-        $primitiveResourceType = null;
-        try 
-        {
-            $primitiveResourceType = ResourceType::getPrimitiveResourceType($typeCode);
-        }
-        catch (InvalidArgumentException $ex)
-        {
-            throw $ex;
-        }
-
-        if ($isETagProperty && $isBag) {
-            throw new InvalidOperationException('Only primitve property can be etag property, bag property cannot be etag property');
-        }
-
-        $kind = $isKey ?  ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY : ResourcePropertyKind::PRIMITIVE;
-        if ($isBag) {    	   
-            $kind = $kind | ResourcePropertyKind::BAG;
-        }
-
-        if ($isETagProperty) {
-            $kind = $kind | ResourcePropertyKind::ETAG;
-        }
-
-        $resourceProperty = new ResourceProperty($name, null, $kind, $primitiveResourceType);
-        $resourceType->addProperty($resourceProperty);
-    }
-    
-    /**
-     * To add a navigation property (resource set or resource reference)
-     * to a resource type
-     * 
-     * @param ResourceType         $resourceType         The resource type to add 
-     *                                                   the resource reference 
-     *                                                   or resource 
-     *                                                   reference set property to
-     * @param string               $name                 The name of the 
-     *                                                   property to add
-     * @param ResourceSet          $targetResourceSet    The resource set the 
-     *                                                   resource reference
-     *                                                   or reference 
-     *                                                   set property 
-     *                                                   ponits to
-     * @param ResourcePropertyKind $resourcePropertyKind The property kind
-     * 
-     * @return void
-     */
-    private function _addReferencePropertyInternal(ResourceType $resourceType, $name, 
-        ResourceSet $targetResourceSet,
-        $resourcePropertyKind
-    ) {
-        try {
-            $resourceType->getInstanceType()->getProperty($name);
-                  
-        } catch (ReflectionException $exception) {
-            throw new InvalidOperationException(
-                'Can\'t add a property which does not exist on the instance type.'
-            );
-        }
-          
-        if (!($resourcePropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE 
-            || $resourcePropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE)
-        ) {
-            throw new InvalidOperationException(
-                'Property kind should be ResourceSetReference or ResourceReference'
-            );
-        }
-
-        $targetResourceType = $targetResourceSet->getResourceType();
-        $resourceProperty = new ResourceProperty($name, null, $resourcePropertyKind, $targetResourceType);
-        $resourceType->addProperty($resourceProperty);
-        
-        //Create instance of AssociationSet for this relationship        
-        $sourceResourceSet = $resourceType->getCustomState();
-        if (is_null($sourceResourceSet)) {
-            throw new InvalidOperationException('Failed to retrieve the custom state from ' . $resourceType->getName());
-        }
-
-        //Customer_Orders_Orders, Order_Customer_Customers 
-        //(source type::name _ source property::name _ target set::name)
-        $assoicationSetKey = $resourceType->getName() . '_' .  $name . '_' . $targetResourceSet->getName();
-        $associationSet = new ResourceAssociationSet(
-            $assoicationSetKey, 
-            new ResourceAssociationSetEnd($sourceResourceSet, $resourceType, $resourceProperty),
-            new ResourceAssociationSetEnd($targetResourceSet, $targetResourceSet->getResourceType(), null)
-        );
-        $this->associationSets[$assoicationSetKey] = $associationSet;
-    }
-    
-}
+<?php
+/** 
+ * Implementation of IDataServiceMetadataProvider.
+ * 
+ * PHP version 5.3
+ * 
+ * @category  Providers
+ * @package   ServiceBaseMetadata
+ * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   SVN: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ * 
+ */
+namespace ODataProducer\Providers\Metadata;
+use ODataProducer\Providers\Metadata\ResourceStreamInfo;
+use ODataProducer\Providers\Metadata\ResourceAssociationSetEnd;
+use ODataProducer\Providers\Metadata\ResourceAssociationSet;
+use ODataProducer\Common\NotImplementedException;
+use ODataProducer\Providers\Metadata\Type\EdmPrimitiveType;
+use ODataProducer\Providers\Metadata\ResourceSet;
+use ODataProducer\Providers\Metadata\ResourcePropertyKind;
+use ODataProducer\Providers\Metadata\ResourceProperty;
+require_once 'ODataProducer\Providers\Metadata\ResourceTypeKind.php';
+require_once 'ODataProducer\Providers\Metadata\ResourceType.php';
+use ODataProducer\Common\InvalidOperationException;
+use ODataProducer\Providers\Metadata\IDataServiceMetadataProvider;
+require_once 'ODataProducer\Providers\Metadata\IDataServiceMetadataProvider.php';
+
+/**
+ * Custom IDataServiceMetadata implementation
+ * 
+ * @category  Providers
+ * @package   ServiceBaseMetadata
+ * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   Release: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ */
+class ServiceBaseMetadata implements IDataServiceMetadataProvider
+{
+    protected $resourceSets = array();
+    protected $resourceTypes = array();
+    protected $associationSets = array();
+    protected $containerName;
+    protected $namespaceName;
+    
+    //Begin Implementation of IDataServiceMetadataProvider
+    /**
+     * get the Container name for the data source.
+     * 
+     * @return String container name
+     */
+    public function getContainerName()
+    {
+        return $this->containerName;
+    }
+    
+    /**
+     * get Namespace name for the data source.
+     * 
+     * @return String namespace
+     */
+    public function getContainerNamespace()
+    {
+        return $this->namespaceName;
+    }
+    
+    /**
+     * get all entity set information.
+     * 
+     * @return array(ResourceSet)
+     */
+    public function getResourceSets()
+    {
+        return array_values($this->resourceSets);
+    }
+    
+    /**
+     * get all resource types in the data source.
+     * 
+     * @return array(ResourceType)
+     */
+    public function getTypes()
+    {
+        return array_values($this->resourceTypes);
+    }
+    
+    /**
+     * get a resource set based on the specified resource set name.
+     * 
+     * @param string $name Name of the resource set
+     * 
+     * @return ResourceSet/NULL resource set with the given name if found 
+     *                          else NULL
+     */
+    public function resolveResourceSet($name)
+    {
+        if (array_key_exists($name, $this->resourceSets)) {
+            return $this->resourceSets[$name];
+        }
+        
+        return null;
+    }
+    
+    /**
+     * get a resource type based on the resource set name.
+     * 
+     * @param string $name Name of the resource set
+     * 
+     * @return ResourceType/NULL resource type with the given resource set
+     *                           name if found else NULL
+     */
+    public function resolveResourceType($name)
+    {
+        if (array_key_exists($name, $this->resourceTypes)) {
+            return $this->resourceTypes[$name];
+        }
+        
+        return null;
+    }
+    
+    /**
+     * The method must return a collection of all the types derived from 
+     * $resourceType The collection returned should NOT include the type 
+     * passed in as a parameter An implementer of the interface should 
+     * return null if the type does not have any derived types.
+     * 
+     * @param ResourceType $resourceType Resource to get derived resource 
+     *                                   types from
+     * 
+     * @return array(ResourceType)/NULL
+     */
+    public function getDerivedTypes(ResourceType $resourceType)
+    {
+        return null;
+    }
+    
+    /**
+     * Returns true if $resourceType represents an Entity Type which has derived
+     *                               Entity Types, else false.
+     * 
+     * @param ResourceType $resourceType Resource to check for derived resource 
+     *                                   types.
+     * 
+     * @return boolean
+     */
+    public function hasDerivedTypes(ResourceType $resourceType)
+    {
+        return false;
+    }
+    
+    /**
+     * Gets the ResourceAssociationSet instance for the given source 
+     * association end.
+     * 
+     * @param ResourceSet      $sourceResourceSet      Resource set 
+     *                                                 of the source
+     *                                                 association end
+     * @param ResourceType     $sourceResourceType     Resource type of the source
+     *                                                 association end
+     * @param ResourceProperty $targetResourceProperty Resource property of 
+     *                                                 the source
+     *                                                 association end
+     * 
+     * @return ResourceAssociationSet
+     */
+    public function getResourceAssociationSet(ResourceSet $sourceResourceSet, ResourceType $sourceResourceType, ResourceProperty $targetResourceProperty)
+    {
+        //e.g.
+        //ResourceSet => Representing 'Customers' entity set
+        //ResourceType => Representing'Customer' entity type
+        //ResourceProperty => Representing 'Orders' property
+        //We have created ResourceAssoicationSet while adding 
+        //ResourceSetReference or ResourceReference
+        //and kept in $this->associationSets
+        //$metadata->addResourceSetReferenceProperty(
+        //             $customersEntityType, 
+        //             'Orders', 
+        //             $ordersResourceSet
+        //             );
+        
+        $targetResourceSet = $targetResourceProperty->getResourceType()->getCustomState();
+        if (is_null($targetResourceSet)) {
+            throw new InvalidOperationException('Failed to retrieve the custom state from ' . $resourceProperty->getResourceType()->getName());
+        }
+
+        //Customer_Orders_Orders, Order_Customer_Customers
+        $key = $sourceResourceType->getName() . '_' . $targetResourceProperty->getName() . '_' . $targetResourceSet->getName();
+        if (array_key_exists($key, $this->associationSets)) {
+            return $this->associationSets[$key];
+        }
+
+        return null;
+    }
+
+    //End Implementation of IDataServiceMetadataProvider
+    
+    /** 
+     * Construct new instance of NorthWindMetadata
+     * 
+     * @param string $containerName container name for the datasource.
+     * @param string $namespaceName namespace for the datasource.
+     * 
+     * @return void
+     */
+    public function __construct($containerName, $namespaceName)
+    {
+        $this->containerName = $containerName;
+        $this->namespaceName = $namespaceName;
+    }
+    
+    /**
+     * Add an entity type
+     * 
+     * @param ReflectionClass $refClass  reflection class of the entity
+     * @param string          $name      name of the entity
+     * @param string          $namespace namespace of the datasource
+     * 
+     * @return ResourceType
+     */
+    public function addEntityType($refClass, $name, $namespace=null)
+    {
+        if (array_key_exists($name, $this->resourceTypes)) {
+            throw new InvalidOperationException('Type with same name already added');
+        }
+        
+        $entityType = new ResourceType($refClass, ResourceTypeKind::ENTITY, $name, $namespace);
+        $this->resourceTypes[$name] = $entityType;
+        return $entityType;
+    }
+    
+    /**
+     * Add a complex type
+     * 
+     * @param ReflectionClass $refClass         reflection class of the 
+     *                                          complex entity type
+     * @param string          $name             name of the entity
+     * @param string          $namespace        namespace of the datasource.
+     * @param ResourceType    $baseResourceType base resource type
+     * 
+     * @return ResourceType
+     */
+    public function addComplexType($refClass, $name, $namespace=null, $baseResourceType = null)
+    {
+        if (array_key_exists($name, $this->resourceTypes)) {
+            throw new InvalidOperationException('Type with same name already added');
+        }
+        
+        $complexType = new ResourceType($refClass, ResourceTypeKind::COMPLEX, $name, $namespace, $baseResourceType);    	
+        $this->resourceTypes[$name] = $complexType;
+        return $complexType;
+    }
+    
+    /**
+     * Add a resouce set
+     * 
+     * @param string      $name         name of the resource set
+     * @param ResouceType $resourceType resource type
+     * 
+     * @throws InvalidOperationException
+     * 
+     * @return ResourceSet
+     */
+    public function addResourceSet($name, $resourceType)
+    {
+        if (array_key_exists($name, $this->resourceSets)) {
+            throw new InvalidOperationException('Resource Set already added');
+        }
+        
+        $this->resourceSets[$name] = new ResourceSet($name, $resourceType);
+        //No support for multiple ResourceSet with same EntityType
+        //So keeping reference to the 'ResourceSet' with the entity type
+        $resourceType->setCustomState($this->resourceSets[$name]);
+        return $this->resourceSets[$name];
+    }
+    
+    /**
+     * To add a Key-primitive property to a resouce (Complex/Entuty)
+     * 
+     * @param ResourceType $resourceType resource type to which key property
+     *                                   is to be added
+     * @param string       $name         name of the key property
+     * @param TypeCode     $typeCode     type of the key property
+     * 
+     * @return void
+     */
+    public function addKeyProperty($resourceType, $name, $typeCode)
+    {
+        $this->_addPrimitivePropertyInternal($resourceType, $name, $typeCode, true);
+    }
+    
+    /**
+     * To add a NonKey-primitive property (Complex/Entity)
+     * 
+     * @param ResourceType $resourceType resource type to which key property
+     *                                   is to be added
+     * @param string       $name         name of the key property
+     * @param TypeCode     $typeCode     type of the key property
+     * @param Boolean      $isBag        property is bag or not
+     * 
+     * @return void
+     */
+    public function addPrimitiveProperty($resourceType, $name, $typeCode, $isBag = false)
+    {
+        $this->_addPrimitivePropertyInternal($resourceType, $name, $typeCode, false, $isBag);
+    }
+
+    /**
+     * To add a non-key etag property
+     * 
+     * @param ResourceType $resourceType resource type to which key property
+     *                                   is to be added
+     * @param String       $name         name of the property
+     * @param String       $typeCode     type of the etag property
+     * 
+     * @return void
+     */
+    public function addETagProperty($resourceType, $name, $typeCode)
+    {
+        $this->_addPrimitivePropertyInternal($resourceType, $name, $typeCode, false, false, true);
+    }
+
+    /**
+     * To add a resource reference property
+     * 
+     * @param ResourceType $resourceType      The resource type to add the resource
+     *                                        reference property to
+     * @param string       $name              The name of the property to add
+     * @param ResourceSet  $targetResourceSet The resource set the resource reference
+     *                                        property points to
+     *                    
+     * @return void                  
+     */
+    public function addResourceReferenceProperty($resourceType, $name, $targetResourceSet)
+    {
+        $this->_addReferencePropertyInternal(
+            $resourceType, 
+            $name, 
+            $targetResourceSet,
+            ResourcePropertyKind::RESOURCE_REFERENCE
+        );
+    }
+
+    /**
+     * To add a resource set reference property
+     *      
+     * @param ResourceType $resourceType      The resource type to add the 
+     *                                        resource reference set property to
+     * @param string       $name              The name of the property to add
+     * @param ResourceSet  $targetResourceSet The resource set the resource 
+     *                                        reference set property points to
+     *                                        
+     * @return void                                      
+     */
+    public function addResourceSetReferenceProperty($resourceType, $name, $targetResourceSet)
+    {
+        $this->_addReferencePropertyInternal(
+            $resourceType, 
+            $name, 
+            $targetResourceSet,
+            ResourcePropertyKind::RESOURCESET_REFERENCE
+        );
+    }
+    
+    /**
+     * To add a complex property to entity or complex type
+     * 
+     * @param ResourceType $resourceType        The resource type to which the 
+     *                                          complex property needs to add
+     * @param string       $name                name of the complex property
+     * @param ResourceType $complexResourceType complex resource type
+     * @param Boolean      $isBag               complex type is bag or not
+     * 
+     * @return ResourceProperty
+     */
+    public function addComplexProperty($resourceType, $name, $complexResourceType, $isBag = false)
+    {
+        if ($resourceType->getResourceTypeKind() != ResourceTypeKind::ENTITY 
+            && $resourceType->getResourceTypeKind() != ResourceTypeKind::COMPLEX
+        ) {
+            throw new InvalidOperationException('complex property can be added to an entity or another complex type');
+        }
+        
+        try 
+        {
+            $resourceType->getInstanceType()->getProperty($name);
+        }
+        catch (ReflectionException $ex)
+        {
+            throw new InvalidOperationException(
+                'Can\'t add a property which does not exist on the instance type.'
+            );
+        }
+
+        $kind = ResourcePropertyKind::COMPLEX_TYPE;
+        if ($isBag) {    	   
+            $kind = $kind | ResourcePropertyKind::BAG;
+        }
+
+        $resourceProperty = new ResourceProperty($name, null, $kind, $complexResourceType);
+        $resourceType->addProperty($resourceProperty);
+        return $resourceProperty;
+    }
+    
+    /**
+     * To add a Key/NonKey-primitive property to a resource (complex/entity)
+     * 
+     * @param ResourceType $resourceType   Resource type
+     * @param string       $name           name of the property
+     * @param TypeCode     $typeCode       type of property
+     * @param boolean      $isKey          property is key or not
+     * @param boolean      $isBag          property is bag or not
+     * @param boolean      $isETagProperty property is etag or not
+     * 
+     * @return void
+     */
+    private function _addPrimitivePropertyInternal($resourceType, $name, $typeCode, $isKey = false, $isBag = false, $isETagProperty = false)
+    {
+        try 
+        {
+            $resourceType->getInstanceType()->getProperty($name);
+        }
+        catch (ReflectionException $ex)
+        {
+            throw new InvalidOperationException(
+                'Can\'t add a property which does not exist on the instance type.'
+            );
+        }
+        
+        $primitiveResourceType = null;
+        try 
+        {
+            $primitiveResourceType = ResourceType::getPrimitiveResourceType($typeCode);
+        }
+        catch (InvalidArgumentException $ex)
+        {
+            throw $ex;
+        }
+
+        if ($isETagProperty && $isBag) {
+            throw new InvalidOperationException('Only primitve property can be etag property, bag property cannot be etag property');
+        }
+
+        $kind = $isKey ?  ResourcePropertyKind::PRIMITIVE | ResourcePropertyKind::KEY : ResourcePropertyKind::PRIMITIVE;
+        if ($isBag) {    	   
+            $kind = $kind | ResourcePropertyKind::BAG;
+        }
+
+        if ($isETagProperty) {
+            $kind = $kind | ResourcePropertyKind::ETAG;
+        }
+
+        $resourceProperty = new ResourceProperty($name, null, $kind, $primitiveResourceType);
+        $resourceType->addProperty($resourceProperty);
+    }
+    
+    /**
+     * To add a navigation property (resource set or resource reference)
+     * to a resource type
+     * 
+     * @param ResourceType         $resourceType         The resource type to add 
+     *                                                   the resource reference 
+     *                                                   or resource 
+     *                                                   reference set property to
+     * @param string               $name                 The name of the 
+     *                                                   property to add
+     * @param ResourceSet          $targetResourceSet    The resource set the 
+     *                                                   resource reference
+     *                                                   or reference 
+     *                                                   set property 
+     *                                                   ponits to
+     * @param ResourcePropertyKind $resourcePropertyKind The property kind
+     * 
+     * @return void
+     */
+    private function _addReferencePropertyInternal(ResourceType $resourceType, $name, 
+        ResourceSet $targetResourceSet,
+        $resourcePropertyKind
+    ) {
+        try {
+            $resourceType->getInstanceType()->getProperty($name);
+                  
+        } catch (ReflectionException $exception) {
+            throw new InvalidOperationException(
+                'Can\'t add a property which does not exist on the instance type.'
+            );
+        }
+          
+        if (!($resourcePropertyKind == ResourcePropertyKind::RESOURCESET_REFERENCE 
+            || $resourcePropertyKind == ResourcePropertyKind::RESOURCE_REFERENCE)
+        ) {
+            throw new InvalidOperationException(
+                'Property kind should be ResourceSetReference or ResourceReference'
+            );
+        }
+
+        $targetResourceType = $targetResourceSet->getResourceType();
+        $resourceProperty = new ResourceProperty($name, null, $resourcePropertyKind, $targetResourceType);
+        $resourceType->addProperty($resourceProperty);
+        
+        //Create instance of AssociationSet for this relationship        
+        $sourceResourceSet = $resourceType->getCustomState();
+        if (is_null($sourceResourceSet)) {
+            throw new InvalidOperationException('Failed to retrieve the custom state from ' . $resourceType->getName());
+        }
+
+        //Customer_Orders_Orders, Order_Customer_Customers 
+        //(source type::name _ source property::name _ target set::name)
+        $assoicationSetKey = $resourceType->getName() . '_' .  $name . '_' . $targetResourceSet->getName();
+        $associationSet = new ResourceAssociationSet(
+            $assoicationSetKey, 
+            new ResourceAssociationSetEnd($sourceResourceSet, $resourceType, $resourceProperty),
+            new ResourceAssociationSetEnd($targetResourceSet, $targetResourceSet->getResourceType(), null)
+        );
+        $this->associationSets[$assoicationSetKey] = $associationSet;
+    }
+    
+}
Index: library/ODataProducer/Providers/Metadata/Type/Boolean.php
===================================================================
--- library/ODataProducer/Providers/Metadata/Type/Boolean.php	(revision 2307)
+++ library/ODataProducer/Providers/Metadata/Type/Boolean.php	(working copy)
@@ -1,118 +1,118 @@
-<?php
-/** 
- * Type to represent boolean
- * 
- * PHP version 5.3
- * 
- * @category  ODataProducer
- * @package   ODataProducer_Providers_Metadata_Type
- * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   SVN: 1.0
- * @link      http://odataphpproducer.codeplex.com
- * 
- */
-namespace ODataProducer\Providers\Metadata\Type;
-/**
- * Type to represent boolean
- * 
- * @category  ODataProducer
- * @package   ODataProducer_Providers_Metadata_Type
- * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   Release: 1.0
- * @link      http://odataphpproducer.codeplex.com
- */
-class Boolean implements IType
-{
-    /**
-     * Gets the type code
-     * Note: implementation of IType::getTypeCode
-     *   
-     * @return TypeCode
-     */
-    public function getTypeCode()
-    {
-        return TypeCode::BOOLEAN;
-    }
-
-    /**
-     * Checks this type is compactible with another type
-     * Note: implementation of IType::isCompatibleWith
-     * 
-     * @param IType $type Type to check compactibility
-     * 
-     * @return boolean 
-     */
-    public function isCompatibleWith(IType $type)
-    {
-        return ($type->getTypeCode() == TypeCode::BOOLEAN);
-    }
-
-    /**
-     * Validate a value in Astoria uri is in a format for this type
-     * Note: implementation of IType::validate
-     * 
-     * @param string $value     The value to validate 
-     * @param string &$outValue The stripped form of $value that can 
-     *                          be used in PHP expressions
-     * 
-     * @return boolean
-     */
-    public function validate($value, &$outValue)
-    {
-        if (strcmp($value, 'true') != 0 && strcmp($value, 'false') != 0) {
-            return false;
-        }
-        
-        $outValue = $value;
-        return true;
-    }
-
-    /**
-     * Convert the given value to a form that can be used in OData uri. 
-     * Note: The calling function should not pass null value, as this 
-     * function will not perform any check for nullability 
-     * 
-     * @param mixed $value Value to convert.
-     * 
-     * @return string
-     */
-    public function convertToOData($value)
-    {
-        if ($value) {
-            return 'true';
-        }
-
-        return 'false';
-    }
-
-    /**
-     * Gets full name of this type in EDM namespace
-     * Note: implementation of IType::getFullTypeName
-     * 
-     * @return string
-     */
-    public function getFullTypeName()
-    {
-        return 'Edm.Boolean';
-    }
-
-    /**
-     * Converts the given string value to boolean type.
-     * 
-     * @param string $stringValue String value to convert.
-     * 
-     * @return boolean
-     */
-    public function convert($stringValue)
-    {
-        if (strcmp($stringValue, 'true') == 0) {
-            return true;
-        }
-
-        return false;
-    }
+<?php
+/** 
+ * Type to represent boolean
+ * 
+ * PHP version 5.3
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_Providers_Metadata_Type
+ * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   SVN: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ * 
+ */
+namespace ODataProducer\Providers\Metadata\Type;
+/**
+ * Type to represent boolean
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_Providers_Metadata_Type
+ * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   Release: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ */
+class Boolean implements IType
+{
+    /**
+     * Gets the type code
+     * Note: implementation of IType::getTypeCode
+     *   
+     * @return TypeCode
+     */
+    public function getTypeCode()
+    {
+        return TypeCode::BOOLEAN;
+    }
+
+    /**
+     * Checks this type is compactible with another type
+     * Note: implementation of IType::isCompatibleWith
+     * 
+     * @param IType $type Type to check compactibility
+     * 
+     * @return boolean 
+     */
+    public function isCompatibleWith(IType $type)
+    {
+        return ($type->getTypeCode() == TypeCode::BOOLEAN);
+    }
+
+    /**
+     * Validate a value in Astoria uri is in a format for this type
+     * Note: implementation of IType::validate
+     * 
+     * @param string $value     The value to validate 
+     * @param string &$outValue The stripped form of $value that can 
+     *                          be used in PHP expressions
+     * 
+     * @return boolean
+     */
+    public function validate($value, &$outValue)
+    {
+        if (strcmp($value, 'true') != 0 && strcmp($value, 'false') != 0) {
+            return false;
+        }
+        
+        $outValue = $value;
+        return true;
+    }
+
+    /**
+     * Convert the given value to a form that can be used in OData uri. 
+     * Note: The calling function should not pass null value, as this 
+     * function will not perform any check for nullability 
+     * 
+     * @param mixed $value Value to convert.
+     * 
+     * @return string
+     */
+    public function convertToOData($value)
+    {
+        if ($value) {
+            return 'true';
+        }
+
+        return 'false';
+    }
+
+    /**
+     * Gets full name of this type in EDM namespace
+     * Note: implementation of IType::getFullTypeName
+     * 
+     * @return string
+     */
+    public function getFullTypeName()
+    {
+        return 'Edm.Boolean';
+    }
+
+    /**
+     * Converts the given string value to boolean type.
+     * 
+     * @param string $stringValue String value to convert.
+     * 
+     * @return boolean
+     */
+    public function convert($stringValue)
+    {
+        if (strcmp($stringValue, 'true') == 0) {
+            return true;
+        }
+
+        return false;
+    }
 }
\ No newline at end of file
Index: library/ODataProducer/Providers/Stream/IDataServiceStreamProvider2.php
===================================================================
--- library/ODataProducer/Providers/Stream/IDataServiceStreamProvider2.php	(revision 2307)
+++ library/ODataProducer/Providers/Stream/IDataServiceStreamProvider2.php	(working copy)
@@ -18,7 +18,7 @@
 namespace ODataProducer\Providers\Stream;
 use ODataProducer\Providers\Metadata\ResourceStreamInfo;
 use ODataProducer\Providers\Stream\IDataServiceStreamProvider;
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Stream'.DIRECTORY_SEPARATOR.'IDataServiceStreamProvider.php';
+require_once 'ODataProducer\Providers\Stream\IDataServiceStreamProvider.php';
 /**
  * The IDataServiceStreamProvider2 interface
  * 
Index: library/ODataProducer/UriProcessor/QueryProcessor/OrderByParser/OrderByParser.php
===================================================================
--- library/ODataProducer/UriProcessor/QueryProcessor/OrderByParser/OrderByParser.php	(revision 2307)
+++ library/ODataProducer/UriProcessor/QueryProcessor/OrderByParser/OrderByParser.php	(working copy)
@@ -1,518 +1,516 @@
-<?php
-/**
- * Class to parse $orderby query option and perform syntax validation 
- * and build 'OrderBy Tree' along with next level of validation, the 
- * created tree is used for building sort functions and 'OrderByInfo' structure.
- * 
- * The syntax of orderby clause is:
- * 
- * OrderByClause         : OrderByPathSegment [, OrderByPathSegment]*
- * OrderByPathSegment    : OrderBySubPathSegment[/OrderBySubPathSegment]*[asc|desc]?
- * OrderBySubPathSegment : identifier
- * 
- * PHP version 5.3
- * 
- * @category  ODataProducer
- * @package   ODataProducer_UriProcessor_QueryProcessor_OrderByParser
- * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   SVN: 1.0
- * @link      http://odataphpproducer.codeplex.com
- * 
- */
-namespace ODataProducer\UriProcessor\QueryProcessor\OrderByParser;
-use ODataProducer\UriProcessor\QueryProcessor\AnonymousFunction;
-use ODataProducer\UriProcessor\QueryProcessor\ExpressionParser\ExpressionLexer;
-use ODataProducer\UriProcessor\QueryProcessor\ExpressionParser\ExpressionTokenId;
-use ODataProducer\Providers\MetadataQueryProviderWrapper;
-use ODataProducer\Providers\Metadata\Type\Binary;
-use ODataProducer\Providers\Metadata\ResourceSetWrapper;
-use ODataProducer\Providers\Metadata\ResourceType;
-use ODataProducer\Providers\Metadata\ResourcePropertyKind;
-use ODataProducer\Common\ODataException;
-use ODataProducer\Common\Messages;
-/**
- * $orderby parser.
- * 
- * @category  ODataProducer
- * @package   ODataProducer_UriProcessor_QueryProcessor_OrderByParser
- * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   Release: 1.0
- * @link      http://odataphpproducer.codeplex.com
- */
-class OrderByParser
-{
-    /**
-     * Collection of anonymous sorter function corrosponding to 
-     * each orderby path segment.
-     * 
-     * @var array(AnonymousFunction)
-     */
-    private $_comparisonFunctions = array();
-
-    /**
-     * The top level sorter function generated from orderby path 
-     * segments.
-     * 
-     * @var AnonymousFunction
-     */
-    private $_topLevelComparisonFunction;
-
-    /**
-     * The structure holds information about the navigation properties 
-     * used in the orderby clause (if any) and orderby path if IDSQP 
-     * implementor want to perform sorting.
-     * 
-     * @var OrderByInfo
-     */
-    private $_orderByInfo;
-
-    /**
-     * Reference to metadata and query provider wrapper
-     * 
-     * @var MetadataQueryProviderWrapper
-     */
-    private $_providerWrapper;
-
-    /**
-     * This object will be of type of the resource set identified by the 
-     * request uri.
-     * 
-     * @var mixed
-     */
-    private $_dummyObject;
-
-    /**
-     * Creates new instance of OrderByParser
-     * 
-     * @param MetadataQueryProviderWrapper $providerWrapper Reference to metadata
-     *                                                      and query provider 
-     *                                                      wrapper
-     */
-    private function __construct(MetadataQueryProviderWrapper $providerWrapper)
-    {
-        $this->_providerWrapper = $providerWrapper;
-    }
-
-    /**
-     * This function perform the following tasks with the help of internal helper
-     * functions
-     * (1) Read the orderby clause and perform basic syntax errors
-     * (2) Build 'Order By Tree', creates anonymous sorter function for each leaf 
-     *     node and check for error
-     * (3) Build 'OrderInfo' structure, holds information about the navigation 
-     *     properties used in the orderby clause (if any) and orderby path if 
-     *     IDSQP implementor want to perform sorting
-     * (4) Build top level anonymous sorter function
-     * (4) Release resources hold by the 'Order By Tree'
-     * (5) Create 'InternalOrderInfo' structure, which wraps 'OrderInfo' and top 
-     *     level sorter function 
-     * 
-     * @param ResourceSetWrapper           $resourceSetWrapper ResourceSetWrapper for
-     *                                                         the resource targetted
-     *                                                         by resource path.
-     * @param ResourceType                 $resourceType       ResourceType for the 
-     *                                                         resource targetted
-     *                                                         by resource path.
-     * @param string                       $orderBy            The orderby clause.
-     * @param MetadataQueryProviderWrapper $providerWrapper    Reference to the 
-     *                                                         wrapper for IDSQP
-     *                                                         and IDSMP impl.
-     * 
-     * @return InternalOrderByInfo
-     * 
-     * @throws ODataException If any error occur while parsing orderby clause
-     */
-    public static function parseOrderByClause(ResourceSetWrapper $resourceSetWrapper, 
-        ResourceType $resourceType, $orderBy, 
-        MetadataQueryProviderWrapper $providerWrapper
-    ) {
-        $orderByParser = new OrderByParser($providerWrapper);
-        try {
-            $orderByParser->_dummyObject 
-                = $resourceType->getInstanceType()->newInstance();
-        } catch (\ReflectionException $reflectionException) {
-            throw ODataException::createInternalServerError(
-                Messages::orderByParserFailedToCreateDummyObject()
-            );
-        }
-        $orderByParser->_rootOrderByNode 
-            = new OrderByRootNode($resourceSetWrapper, $resourceType);
-        $orderByPathSegments = $orderByParser->_readOrderBy($orderBy);
-        $orderByParser->_buildOrderByTree($orderByPathSegments);
-        $orderByParser->_createOrderInfo($orderByPathSegments);
-        $orderByParser->_generateTopLevelComparisonFunction();
-        //Recursively release the resources
-        $orderByParser->_rootOrderByNode->free();
-        //creates internal order info wrapper 
-        $internalOrderInfo = new InternalOrderByInfo(
-            $orderByParser->_orderByInfo, 
-            $orderByParser->_comparisonFunctions, 
-            $orderByParser->_topLevelComparisonFunction, 
-            $orderByParser->_dummyObject
-        );
-        unset($orderByParser->_orderByInfo);
-        unset($orderByParser->_topLevelComparisonFunction);
-        return $internalOrderInfo;        
-    }
-
-    /**
-     * Build 'OrderBy Tree' from the given orderby path segments, also build 
-     * comparsion function for each path segment.
-     * 
-     * @param array(array) &$ordeyByPathSegments Collection of orderby path segments,
-     *                                           this is passed by reference
-     *                                           since we need this function to 
-     *                                           modify this array in two cases:
-     *                                           1. if asc or desc present, then the 
-     *                                              corrosponding sub path segment 
-     *                                              should be removed
-     *                                           2. remove duplicate orderby path 
-     *                                              segment
-     * 
-     * @return void
-     * 
-     * @throws ODataException If any error occurs while processing the orderby path 
-     *                        segments
-     */
-    private function _buildOrderByTree(&$ordeyByPathSegments)
-    {
-        foreach ($ordeyByPathSegments as $index1 => &$ordeyBySubPathSegments) {
-            $currentNode = $this->_rootOrderByNode;
-            $currentObject = $this->_dummyObject;
-            $ascending = true;
-            $subPathCount = count($ordeyBySubPathSegments);
-            // Check sort order is specified in the path, if so set a 
-            // flag and remove that segment
-            if ($subPathCount > 1) {
-                if ($ordeyBySubPathSegments[$subPathCount - 1] === '*desc') {
-                    $ascending = false;
-                    unset($ordeyBySubPathSegments[$subPathCount - 1]);
-                    $subPathCount--;
-                } else if ($ordeyBySubPathSegments[$subPathCount - 1] === '*asc') {
-                    unset($ordeyBySubPathSegments[$subPathCount - 1]);
-                    $subPathCount--;
-                }
-            }
-
-            $ancestors = array(
-                $this->_rootOrderByNode->getResourceSetWrapper()->getName()
-            );
-            foreach ($ordeyBySubPathSegments as $index2 => $orderBySubPathSegment) {
-                $isLastSegment = ($index2 == $subPathCount - 1);
-                $resourceSetWrapper = null;
-                $resourceType = $currentNode->getResourceType();
-				var_dump($resourceType);
-				die('test');
-                $resourceProperty 
-                    = $resourceType->tryResolvePropertyTypeByName(
-                        $orderBySubPathSegment
-                    );
-                if (is_null($resourceProperty)) {
-                    ODataException::createSyntaxError(
-                        Messages::orderByParserPropertyNotFound(
-                            $resourceType->getFullName(), $orderBySubPathSegment
-                        )
-                    );
-                }
-
-                if ($resourceProperty->isKindOf(ResourcePropertyKind::BAG)) {
-                    ODataException::createBadRequestError(
-                        Messages::orderByParserBagPropertyNotAllowed(
-                            $resourceProperty->getName()
-                        )
-                    );
-                } else if ($resourceProperty->isKindOf(ResourcePropertyKind::PRIMITIVE)) {
-                    if (!$isLastSegment) {
-                        ODataException::createBadRequestError(
-                            Messages::orderByParserPrimitiveAsIntermediateSegment(
-                                $resourceProperty->getName()
-                            )
-                        );
-                    }
-
-                    $type = $resourceProperty->getInstanceType();
-                    if ($type instanceof Binary) {
-                        ODataException::createBadRequestError(Messages::orderbyParserSortByBinaryPropertyNotAllowed($resourceProperty->getName()));
-                    }
-                } else if ($resourceProperty->getKind() == ResourcePropertyKind::RESOURCESET_REFERENCE 
-                    || $resourceProperty->getKind() == ResourcePropertyKind::RESOURCE_REFERENCE
-                ) {
-                    $this->_assertion(
-                        $currentNode instanceof OrderByRootNode 
-                        || $currentNode instanceof OrderByNode
-                    );
-                    $resourceSetWrapper = $currentNode->getResourceSetWrapper();
-                    $this->_assertion(!is_null($resourceSetWrapper));
-                    $resourceSetWrapper 
-                        = $this->_providerWrapper->getResourceSetWrapperForNavigationProperty(
-                            $resourceSetWrapper, $resourceType, $resourceProperty
-                        );
-                    if (is_null($resourceSetWrapper)) {
-                        ODataException::createBadRequestError(
-                            Messages::badRequestInvalidPropertyNameSpecified(
-                                $resourceType->getFullName(), $orderBySubPathSegment
-                            )
-                        );
-                    }
-
-                    if ($resourceProperty->getKind() == ResourcePropertyKind::RESOURCESET_REFERENCE) {
-                        ODataException::createBadRequestError(
-                            Messages::orderbyParserResourceSetReferenceNotAllowed(
-                                $resourceProperty->getName(), $resourceType->getFullName()
-                            )
-                        );
-                    }
-
-                    $resourceSetWrapper->checkResourceSetRightsForRead(true);
-                    if ($isLastSegment) {
-                        ODataException::createBadRequestError(
-                            Messages::orderByParserSortByNavigationPropertyIsNotAllowed(
-                                $resourceProperty->getName()
-                            )
-                        );
-                    }
-
-                    $ancestors[] = $orderBySubPathSegment;
-                } else if ($resourceProperty->isKindOf(ResourcePropertyKind::COMPLEX_TYPE)) {
-                    if ($isLastSegment) {
-                        ODataException::createBadRequestError(
-                            Messages::orderByParserSortByComplexPropertyIsNotAllowed(
-                                $resourceProperty->getName()
-                            )
-                        );
-                    }
-
-                    $ancestors[] = $orderBySubPathSegment;
-                } else {
-                    ODataException::createInternalServerError(
-                        Messages::orderByParserUnexpectedPropertyType()
-                    );
-                }
-
-                $node = $currentNode->findNode($orderBySubPathSegment);
-                if (is_null($node)) {
-                    if ($resourceProperty->isKindOf(ResourcePropertyKind::PRIMITIVE)) {
-                        $node = new OrderByLeafNode(
-                            $orderBySubPathSegment, $resourceProperty, 
-                            $ascending
-                        );                        
-                        $this->_comparisonFunctions[] 
-                            = $node->buildComparisonFunction($ancestors);
-                    } else if ($resourceProperty->getKind() == ResourcePropertyKind::RESOURCE_REFERENCE) {
-                        $node = new OrderByNode(
-                            $orderBySubPathSegment, $resourceProperty, 
-                            $resourceSetWrapper
-                        );
-                        // Initialize this member variable (identified by 
-                        // $resourceProperty) of parent object. 
-                        try {
-                            $dummyProperty 
-                                = new \ReflectionProperty(
-                                    $currentObject, $resourceProperty->getName()
-                                );
-                            $object = $resourceProperty->getInstanceType()->newInstance();
-                            $dummyProperty->setValue($currentObject, $object);
-                            $currentObject = $object;
-                        } catch (\ReflectionException $reflectionException) {
-                            throw ODataException::createInternalServerError(
-                                Messages::orderByParserFailedToAccessOrInitializeProperty(
-                                    $resourceProperty->getName(), $resourceType->getName()
-                                )
-                            );
-                        }
-                    } else if ($resourceProperty->getKind() == ResourcePropertyKind::COMPLEX_TYPE) {
-                        $node = new OrderByNode($orderBySubPathSegment, $resourceProperty, null);
-                        // Initialize this member variable
-                        // (identified by $resourceProperty)of parent object. 
-                        try {
-                            $dummyProperty 
-                                = new \ReflectionProperty(
-                                    $currentObject, $resourceProperty->getName()
-                                );
-                            $object = $resourceProperty->getInstanceType()->newInstance();
-                            $dummyProperty->setValue($currentObject, $object);
-                            $currentObject = $object;
-                        } catch (\ReflectionException $reflectionException) {
-                            throw ODataException::createInternalServerError(
-                                Messages::orderByParserFailedToAccessOrInitializeProperty(
-                                    $resourceProperty->getName(), $resourceType->getName()
-                                )
-                            );
-                        }
-                    }
-
-                    $currentNode->addNode($node);
-                } else {
-                    try {
-                        $dummyProperty = new \ReflectionProperty(
-                            $currentObject, $resourceProperty->getName()
-                        );
-                        $currentObject = $dummyProperty->getValue($currentObject);
-                    } catch (\ReflectionException $reflectionException) {
-                            throw ODataException::createInternalServerError(
-                                Messages::orderByParserFailedToAccessOrInitializeProperty(
-                                    $resourceProperty->getName(), 
-                                    $resourceType->getName()
-                                )
-                            );
-                    }
-
-                    if ($node instanceof OrderByLeafNode) {
-                        //remove duplicate orderby path
-                        unset($ordeyByPathSegments[$index1]);
-                    }
-                }
-
-                $currentNode = $node;
-            }
-        }
-    }
-
-    /**
-     * Traverse 'Order By Tree' and create 'OrderInfo' structure
-     * 
-     * @param array(array) $ordeyByPaths The orderby paths.
-     * 
-     * @return OrderInfo
-     * 
-     * @throws ODataException In case parser found any tree inconsisitent 
-     *                        state, throws unexpected state error 
-     */
-    private function _createOrderInfo($ordeyByPaths)
-    {
-        $orderByPathSegments = array();
-        $navigationPropertiesInThePath = array();
-        foreach ($ordeyByPaths as $index => $ordeyBySubPaths) {
-            $currentNode = $this->_rootOrderByNode;
-            $orderBySubPathSegments = array();
-            foreach ($ordeyBySubPaths as $ordeyBySubPath) {
-                $node = $currentNode->findNode($ordeyBySubPath);
-                $this->_assertion(!is_null($node));
-                $resourceProperty = $node->getResourceProperty();
-                if ($node instanceof OrderByNode && !is_null($node->getResourceSetWrapper())) {
-                    if (!array_key_exists($index, $navigationPropertiesInThePath)) {
-                        $navigationPropertiesInThePath[$index] = array();
-                    }
-
-                    $navigationPropertiesInThePath[$index][] = $resourceProperty;
-                }
-
-                $orderBySubPathSegments[] = new OrderBySubPathSegment($resourceProperty);
-                $currentNode = $node;
-            }
-
-            $this->_assertion($currentNode instanceof OrderByLeafNode);
-            $orderByPathSegments[] = new OrderByPathSegment($orderBySubPathSegments, $currentNode->isAscending());
-            unset($orderBySubPathSegments);
-        }
-
-        $this->_orderByInfo = new OrderByInfo($orderByPathSegments, empty($navigationPropertiesInThePath) ? null : $navigationPropertiesInThePath);
-    }
-
-    /**
-     * Generates top tevel comparison function from sub comparison functions. 
-     * 
-     * @return void
-     */
-    private function _generateTopLevelComparisonFunction()
-    {
-        $comparsionFunctionCount = count($this->_comparisonFunctions);
-        $this->_assertion($comparsionFunctionCount > 0);
-        $parameters = $this->_comparisonFunctions[0]->getParameters();
-        //$parameters[] = '&$matchLevel = 0';
-        if ($comparsionFunctionCount == 1) {
-            $this->_topLevelComparisonFunction = $this->_comparisonFunctions[0];
-        } else {
-            $code = null;
-            for ($i = 0; $i < $comparsionFunctionCount; $i++) {
-                $subComparsionFunctionName = substr($this->_comparisonFunctions[$i]->getReference(), 1);
-                $code .= "\$result = call_user_func_array(chr(0) . '$subComparsionFunctionName', array($parameters[0], $parameters[1]));";
-                $code .= "
-                         if (\$result != 0) {
-                            return \$result;
-                         }
-                         ";
-            }
-
-            $code .= "return \$result;";
-            $this->_topLevelComparisonFunction = new AnonymousFunction($parameters, $code);
-        }        
-    }
-
-    /**
-     * Read orderby clause.
-     * 
-     * @param string $value orderby clause to read.
-     * 
-     * @return array(array) An array of 'OrderByPathSegment's, each of which 
-     *                      is array of 'OrderBySubPathSegment's
-     * 
-     * @throws ODataException If any syntax error found while reading the clause
-     */
-    private function _readOrderBy($value)
-    {
-        $orderByPathSegments = array();
-        $lexer = new ExpressionLexer($value);
-        $i = 0;
-        while ($lexer->getCurrentToken()->Id != ExpressionTokenId::END) {
-            $orderBySubPathSegment = $lexer->readDottedIdentifier();
-            if (!array_key_exists($i, $orderByPathSegments)) {
-                $orderByPathSegments[$i] = array();
-            }
-
-            $orderByPathSegments[$i][] = $orderBySubPathSegment;
-            $tokenId = $lexer->getCurrentToken()->Id;
-            if ($tokenId != ExpressionTokenId::END) {
-                if ($tokenId != ExpressionTokenId::SLASH) {
-                    if ($tokenId != ExpressionTokenId::COMMA) {
-                        $lexer->validateToken(ExpressionTokenId::IDENTIFIER);
-                        $identifier = $lexer->getCurrentToken()->Text;
-                        if ($identifier !== 'asc' && $identifier !== 'desc') {
-                            // force lexer to throw syntax error as we found 
-                            // unexpected identifier
-                            $lexer->validateToken(ExpressionTokenId::DOT);
-                        }
-
-                        $orderByPathSegments[$i][] = '*' . $identifier;
-                        $lexer->nextToken();
-                        $tokenId = $lexer->getCurrentToken()->Id;
-                        if ($tokenId != ExpressionTokenId::END) {
-                            $lexer->validateToken(ExpressionTokenId::COMMA);
-                            $i++;
-                        }
-                    } else {
-                        $i++;
-                    }
-                }
-
-                $lexer->nextToken();
-            }
-        }
-
-        return $orderByPathSegments;
-    }
-
-    /**
-     * Assert that the given condition is true, if false throw 
-     * ODataException for unexpected state
-     * 
-     * @param boolean $condition The condition to assert
-     * 
-     * @return void
-     * 
-     * @throws ODataException
-     */
-    private function _assertion($condition)
-    {
-        if (!$condition) {
-            ODataException::createInternalServerError(
-                Messages::orderByParserUnExpectedState()
-            );
-        }
-    }
-}
+<?php
+/**
+ * Class to parse $orderby query option and perform syntax validation 
+ * and build 'OrderBy Tree' along with next level of validation, the 
+ * created tree is used for building sort functions and 'OrderByInfo' structure.
+ * 
+ * The syntax of orderby clause is:
+ * 
+ * OrderByClause         : OrderByPathSegment [, OrderByPathSegment]*
+ * OrderByPathSegment    : OrderBySubPathSegment[/OrderBySubPathSegment]*[asc|desc]?
+ * OrderBySubPathSegment : identifier
+ * 
+ * PHP version 5.3
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_UriProcessor_QueryProcessor_OrderByParser
+ * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   SVN: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ * 
+ */
+namespace ODataProducer\UriProcessor\QueryProcessor\OrderByParser;
+use ODataProducer\UriProcessor\QueryProcessor\AnonymousFunction;
+use ODataProducer\UriProcessor\QueryProcessor\ExpressionParser\ExpressionLexer;
+use ODataProducer\UriProcessor\QueryProcessor\ExpressionParser\ExpressionTokenId;
+use ODataProducer\Providers\MetadataQueryProviderWrapper;
+use ODataProducer\Providers\Metadata\Type\Binary;
+use ODataProducer\Providers\Metadata\ResourceSetWrapper;
+use ODataProducer\Providers\Metadata\ResourceType;
+use ODataProducer\Providers\Metadata\ResourcePropertyKind;
+use ODataProducer\Common\ODataException;
+use ODataProducer\Common\Messages;
+/**
+ * $orderby parser.
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_UriProcessor_QueryProcessor_OrderByParser
+ * @author    Anu T Chandy <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   Release: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ */
+class OrderByParser
+{
+    /**
+     * Collection of anonymous sorter function corrosponding to 
+     * each orderby path segment.
+     * 
+     * @var array(AnonymousFunction)
+     */
+    private $_comparisonFunctions = array();
+
+    /**
+     * The top level sorter function generated from orderby path 
+     * segments.
+     * 
+     * @var AnonymousFunction
+     */
+    private $_topLevelComparisonFunction;
+
+    /**
+     * The structure holds information about the navigation properties 
+     * used in the orderby clause (if any) and orderby path if IDSQP 
+     * implementor want to perform sorting.
+     * 
+     * @var OrderByInfo
+     */
+    private $_orderByInfo;
+
+    /**
+     * Reference to metadata and query provider wrapper
+     * 
+     * @var MetadataQueryProviderWrapper
+     */
+    private $_providerWrapper;
+
+    /**
+     * This object will be of type of the resource set identified by the 
+     * request uri.
+     * 
+     * @var mixed
+     */
+    private $_dummyObject;
+
+    /**
+     * Creates new instance of OrderByParser
+     * 
+     * @param MetadataQueryProviderWrapper $providerWrapper Reference to metadata
+     *                                                      and query provider 
+     *                                                      wrapper
+     */
+    private function __construct(MetadataQueryProviderWrapper $providerWrapper)
+    {
+        $this->_providerWrapper = $providerWrapper;
+    }
+
+    /**
+     * This function perform the following tasks with the help of internal helper
+     * functions
+     * (1) Read the orderby clause and perform basic syntax errors
+     * (2) Build 'Order By Tree', creates anonymous sorter function for each leaf 
+     *     node and check for error
+     * (3) Build 'OrderInfo' structure, holds information about the navigation 
+     *     properties used in the orderby clause (if any) and orderby path if 
+     *     IDSQP implementor want to perform sorting
+     * (4) Build top level anonymous sorter function
+     * (4) Release resources hold by the 'Order By Tree'
+     * (5) Create 'InternalOrderInfo' structure, which wraps 'OrderInfo' and top 
+     *     level sorter function 
+     * 
+     * @param ResourceSetWrapper           $resourceSetWrapper ResourceSetWrapper for
+     *                                                         the resource targetted
+     *                                                         by resource path.
+     * @param ResourceType                 $resourceType       ResourceType for the 
+     *                                                         resource targetted
+     *                                                         by resource path.
+     * @param string                       $orderBy            The orderby clause.
+     * @param MetadataQueryProviderWrapper $providerWrapper    Reference to the 
+     *                                                         wrapper for IDSQP
+     *                                                         and IDSMP impl.
+     * 
+     * @return InternalOrderByInfo
+     * 
+     * @throws ODataException If any error occur while parsing orderby clause
+     */
+    public static function parseOrderByClause(ResourceSetWrapper $resourceSetWrapper, 
+        ResourceType $resourceType, $orderBy, 
+        MetadataQueryProviderWrapper $providerWrapper
+    ) {
+        $orderByParser = new OrderByParser($providerWrapper);
+        try {
+            $orderByParser->_dummyObject 
+                = $resourceType->getInstanceType()->newInstance();
+        } catch (\ReflectionException $reflectionException) {
+            throw ODataException::createInternalServerError(
+                Messages::orderByParserFailedToCreateDummyObject()
+            );
+        }
+        $orderByParser->_rootOrderByNode 
+            = new OrderByRootNode($resourceSetWrapper, $resourceType);
+        $orderByPathSegments = $orderByParser->_readOrderBy($orderBy);
+        $orderByParser->_buildOrderByTree($orderByPathSegments);
+        $orderByParser->_createOrderInfo($orderByPathSegments);
+        $orderByParser->_generateTopLevelComparisonFunction();
+        //Recursively release the resources
+        $orderByParser->_rootOrderByNode->free();
+        //creates internal order info wrapper 
+        $internalOrderInfo = new InternalOrderByInfo(
+            $orderByParser->_orderByInfo, 
+            $orderByParser->_comparisonFunctions, 
+            $orderByParser->_topLevelComparisonFunction, 
+            $orderByParser->_dummyObject
+        );
+        unset($orderByParser->_orderByInfo);
+        unset($orderByParser->_topLevelComparisonFunction);
+        return $internalOrderInfo;        
+    }
+
+    /**
+     * Build 'OrderBy Tree' from the given orderby path segments, also build 
+     * comparsion function for each path segment.
+     * 
+     * @param array(array) &$ordeyByPathSegments Collection of orderby path segments,
+     *                                           this is passed by reference
+     *                                           since we need this function to 
+     *                                           modify this array in two cases:
+     *                                           1. if asc or desc present, then the 
+     *                                              corrosponding sub path segment 
+     *                                              should be removed
+     *                                           2. remove duplicate orderby path 
+     *                                              segment
+     * 
+     * @return void
+     * 
+     * @throws ODataException If any error occurs while processing the orderby path 
+     *                        segments
+     */
+    private function _buildOrderByTree(&$ordeyByPathSegments)
+    {
+        foreach ($ordeyByPathSegments as $index1 => &$ordeyBySubPathSegments) {
+            $currentNode = $this->_rootOrderByNode;
+            $currentObject = $this->_dummyObject;
+            $ascending = true;
+            $subPathCount = count($ordeyBySubPathSegments);
+            // Check sort order is specified in the path, if so set a 
+            // flag and remove that segment
+            if ($subPathCount > 1) {
+                if ($ordeyBySubPathSegments[$subPathCount - 1] === '*desc') {
+                    $ascending = false;
+                    unset($ordeyBySubPathSegments[$subPathCount - 1]);
+                    $subPathCount--;
+                } else if ($ordeyBySubPathSegments[$subPathCount - 1] === '*asc') {
+                    unset($ordeyBySubPathSegments[$subPathCount - 1]);
+                    $subPathCount--;
+                }
+            }
+
+            $ancestors = array(
+                $this->_rootOrderByNode->getResourceSetWrapper()->getName()
+            );
+            foreach ($ordeyBySubPathSegments as $index2 => $orderBySubPathSegment) {
+                $isLastSegment = ($index2 == $subPathCount - 1);
+                $resourceSetWrapper = null;
+                $resourceType = $currentNode->getResourceType();
+                $resourceProperty 
+                    = $resourceType->tryResolvePropertyTypeByName(
+                        $orderBySubPathSegment
+                    );
+                if (is_null($resourceProperty)) {
+                    ODataException::createSyntaxError(
+                        Messages::orderByParserPropertyNotFound(
+                            $resourceType->getFullName(), $orderBySubPathSegment
+                        )
+                    );
+                }
+
+                if ($resourceProperty->isKindOf(ResourcePropertyKind::BAG)) {
+                    ODataException::createBadRequestError(
+                        Messages::orderByParserBagPropertyNotAllowed(
+                            $resourceProperty->getName()
+                        )
+                    );
+                } else if ($resourceProperty->isKindOf(ResourcePropertyKind::PRIMITIVE)) {
+                    if (!$isLastSegment) {
+                        ODataException::createBadRequestError(
+                            Messages::orderByParserPrimitiveAsIntermediateSegment(
+                                $resourceProperty->getName()
+                            )
+                        );
+                    }
+
+                    $type = $resourceProperty->getInstanceType();
+                    if ($type instanceof Binary) {
+                        ODataException::createBadRequestError(Messages::orderbyParserSortByBinaryPropertyNotAllowed($resourceProperty->getName()));
+                    }
+                } else if ($resourceProperty->getKind() == ResourcePropertyKind::RESOURCESET_REFERENCE 
+                    || $resourceProperty->getKind() == ResourcePropertyKind::RESOURCE_REFERENCE
+                ) {
+                    $this->_assertion(
+                        $currentNode instanceof OrderByRootNode 
+                        || $currentNode instanceof OrderByNode
+                    );
+                    $resourceSetWrapper = $currentNode->getResourceSetWrapper();
+                    $this->_assertion(!is_null($resourceSetWrapper));
+                    $resourceSetWrapper 
+                        = $this->_providerWrapper->getResourceSetWrapperForNavigationProperty(
+                            $resourceSetWrapper, $resourceType, $resourceProperty
+                        );
+                    if (is_null($resourceSetWrapper)) {
+                        ODataException::createBadRequestError(
+                            Messages::badRequestInvalidPropertyNameSpecified(
+                                $resourceType->getFullName(), $orderBySubPathSegment
+                            )
+                        );
+                    }
+
+                    if ($resourceProperty->getKind() == ResourcePropertyKind::RESOURCESET_REFERENCE) {
+                        ODataException::createBadRequestError(
+                            Messages::orderbyParserResourceSetReferenceNotAllowed(
+                                $resourceProperty->getName(), $resourceType->getFullName()
+                            )
+                        );
+                    }
+
+                    $resourceSetWrapper->checkResourceSetRightsForRead(true);
+                    if ($isLastSegment) {
+                        ODataException::createBadRequestError(
+                            Messages::orderByParserSortByNavigationPropertyIsNotAllowed(
+                                $resourceProperty->getName()
+                            )
+                        );
+                    }
+
+                    $ancestors[] = $orderBySubPathSegment;
+                } else if ($resourceProperty->isKindOf(ResourcePropertyKind::COMPLEX_TYPE)) {
+                    if ($isLastSegment) {
+                        ODataException::createBadRequestError(
+                            Messages::orderByParserSortByComplexPropertyIsNotAllowed(
+                                $resourceProperty->getName()
+                            )
+                        );
+                    }
+
+                    $ancestors[] = $orderBySubPathSegment;
+                } else {
+                    ODataException::createInternalServerError(
+                        Messages::orderByParserUnexpectedPropertyType()
+                    );
+                }
+
+                $node = $currentNode->findNode($orderBySubPathSegment);
+                if (is_null($node)) {
+                    if ($resourceProperty->isKindOf(ResourcePropertyKind::PRIMITIVE)) {
+                        $node = new OrderByLeafNode(
+                            $orderBySubPathSegment, $resourceProperty, 
+                            $ascending
+                        );                        
+                        $this->_comparisonFunctions[] 
+                            = $node->buildComparisonFunction($ancestors);
+                    } else if ($resourceProperty->getKind() == ResourcePropertyKind::RESOURCE_REFERENCE) {
+                        $node = new OrderByNode(
+                            $orderBySubPathSegment, $resourceProperty, 
+                            $resourceSetWrapper
+                        );
+                        // Initialize this member variable (identified by 
+                        // $resourceProperty) of parent object. 
+                        try {
+                            $dummyProperty 
+                                = new \ReflectionProperty(
+                                    $currentObject, $resourceProperty->getName()
+                                );
+                            $object = $resourceProperty->getInstanceType()->newInstance();
+                            $dummyProperty->setValue($currentObject, $object);
+                            $currentObject = $object;
+                        } catch (\ReflectionException $reflectionException) {
+                            throw ODataException::createInternalServerError(
+                                Messages::orderByParserFailedToAccessOrInitializeProperty(
+                                    $resourceProperty->getName(), $resourceType->getName()
+                                )
+                            );
+                        }
+                    } else if ($resourceProperty->getKind() == ResourcePropertyKind::COMPLEX_TYPE) {
+                        $node = new OrderByNode($orderBySubPathSegment, $resourceProperty, null);
+                        // Initialize this member variable
+                        // (identified by $resourceProperty)of parent object. 
+                        try {
+                            $dummyProperty 
+                                = new \ReflectionProperty(
+                                    $currentObject, $resourceProperty->getName()
+                                );
+                            $object = $resourceProperty->getInstanceType()->newInstance();
+                            $dummyProperty->setValue($currentObject, $object);
+                            $currentObject = $object;
+                        } catch (\ReflectionException $reflectionException) {
+                            throw ODataException::createInternalServerError(
+                                Messages::orderByParserFailedToAccessOrInitializeProperty(
+                                    $resourceProperty->getName(), $resourceType->getName()
+                                )
+                            );
+                        }
+                    }
+
+                    $currentNode->addNode($node);
+                } else {
+                    try {
+                        $dummyProperty = new \ReflectionProperty(
+                            $currentObject, $resourceProperty->getName()
+                        );
+                        $currentObject = $dummyProperty->getValue($currentObject);
+                    } catch (\ReflectionException $reflectionException) {
+                            throw ODataException::createInternalServerError(
+                                Messages::orderByParserFailedToAccessOrInitializeProperty(
+                                    $resourceProperty->getName(), 
+                                    $resourceType->getName()
+                                )
+                            );
+                    }
+
+                    if ($node instanceof OrderByLeafNode) {
+                        //remove duplicate orderby path
+                        unset($ordeyByPathSegments[$index1]);
+                    }
+                }
+
+                $currentNode = $node;
+            }
+        }
+    }
+
+    /**
+     * Traverse 'Order By Tree' and create 'OrderInfo' structure
+     * 
+     * @param array(array) $ordeyByPaths The orderby paths.
+     * 
+     * @return OrderInfo
+     * 
+     * @throws ODataException In case parser found any tree inconsisitent 
+     *                        state, throws unexpected state error 
+     */
+    private function _createOrderInfo($ordeyByPaths)
+    {
+        $orderByPathSegments = array();
+        $navigationPropertiesInThePath = array();
+        foreach ($ordeyByPaths as $index => $ordeyBySubPaths) {
+            $currentNode = $this->_rootOrderByNode;
+            $orderBySubPathSegments = array();
+            foreach ($ordeyBySubPaths as $ordeyBySubPath) {
+                $node = $currentNode->findNode($ordeyBySubPath);
+                $this->_assertion(!is_null($node));
+                $resourceProperty = $node->getResourceProperty();
+                if ($node instanceof OrderByNode && !is_null($node->getResourceSetWrapper())) {
+                    if (!array_key_exists($index, $navigationPropertiesInThePath)) {
+                        $navigationPropertiesInThePath[$index] = array();
+                    }
+
+                    $navigationPropertiesInThePath[$index][] = $resourceProperty;
+                }
+
+                $orderBySubPathSegments[] = new OrderBySubPathSegment($resourceProperty);
+                $currentNode = $node;
+            }
+
+            $this->_assertion($currentNode instanceof OrderByLeafNode);
+            $orderByPathSegments[] = new OrderByPathSegment($orderBySubPathSegments, $currentNode->isAscending());
+            unset($orderBySubPathSegments);
+        }
+
+        $this->_orderByInfo = new OrderByInfo($orderByPathSegments, empty($navigationPropertiesInThePath) ? null : $navigationPropertiesInThePath);
+    }
+
+    /**
+     * Generates top tevel comparison function from sub comparison functions. 
+     * 
+     * @return void
+     */
+    private function _generateTopLevelComparisonFunction()
+    {
+        $comparsionFunctionCount = count($this->_comparisonFunctions);
+        $this->_assertion($comparsionFunctionCount > 0);
+        $parameters = $this->_comparisonFunctions[0]->getParameters();
+        //$parameters[] = '&$matchLevel = 0';
+        if ($comparsionFunctionCount == 1) {
+            $this->_topLevelComparisonFunction = $this->_comparisonFunctions[0];
+        } else {
+            $code = null;
+            for ($i = 0; $i < $comparsionFunctionCount; $i++) {
+                $subComparsionFunctionName = substr($this->_comparisonFunctions[$i]->getReference(), 1);
+                $code .= "\$result = call_user_func_array(chr(0) . '$subComparsionFunctionName', array($parameters[0], $parameters[1]));";
+                $code .= "
+                         if (\$result != 0) {
+                            return \$result;
+                         }
+                         ";
+            }
+
+            $code .= "return \$result;";
+            $this->_topLevelComparisonFunction = new AnonymousFunction($parameters, $code);
+        }        
+    }
+
+    /**
+     * Read orderby clause.
+     * 
+     * @param string $value orderby clause to read.
+     * 
+     * @return array(array) An array of 'OrderByPathSegment's, each of which 
+     *                      is array of 'OrderBySubPathSegment's
+     * 
+     * @throws ODataException If any syntax error found while reading the clause
+     */
+    private function _readOrderBy($value)
+    {
+        $orderByPathSegments = array();
+        $lexer = new ExpressionLexer($value);
+        $i = 0;
+        while ($lexer->getCurrentToken()->Id != ExpressionTokenId::END) {
+            $orderBySubPathSegment = $lexer->readDottedIdentifier();
+            if (!array_key_exists($i, $orderByPathSegments)) {
+                $orderByPathSegments[$i] = array();
+            }
+
+            $orderByPathSegments[$i][] = $orderBySubPathSegment;
+            $tokenId = $lexer->getCurrentToken()->Id;
+            if ($tokenId != ExpressionTokenId::END) {
+                if ($tokenId != ExpressionTokenId::SLASH) {
+                    if ($tokenId != ExpressionTokenId::COMMA) {
+                        $lexer->validateToken(ExpressionTokenId::IDENTIFIER);
+                        $identifier = $lexer->getCurrentToken()->Text;
+                        if ($identifier !== 'asc' && $identifier !== 'desc') {
+                            // force lexer to throw syntax error as we found 
+                            // unexpected identifier
+                            $lexer->validateToken(ExpressionTokenId::DOT);
+                        }
+
+                        $orderByPathSegments[$i][] = '*' . $identifier;
+                        $lexer->nextToken();
+                        $tokenId = $lexer->getCurrentToken()->Id;
+                        if ($tokenId != ExpressionTokenId::END) {
+                            $lexer->validateToken(ExpressionTokenId::COMMA);
+                            $i++;
+                        }
+                    } else {
+                        $i++;
+                    }
+                }
+
+                $lexer->nextToken();
+            }
+        }
+
+        return $orderByPathSegments;
+    }
+
+    /**
+     * Assert that the given condition is true, if false throw 
+     * ODataException for unexpected state
+     * 
+     * @param boolean $condition The condition to assert
+     * 
+     * @return void
+     * 
+     * @throws ODataException
+     */
+    private function _assertion($condition)
+    {
+        if (!$condition) {
+            ODataException::createInternalServerError(
+                Messages::orderByParserUnExpectedState()
+            );
+        }
+    }
+}
 ?>
\ No newline at end of file
Index: library/ODataProducer/UriProcessor/QueryProcessor/QueryProcessor.php
===================================================================
--- library/ODataProducer/UriProcessor/QueryProcessor/QueryProcessor.php	(revision 2307)
+++ library/ODataProducer/UriProcessor/QueryProcessor/QueryProcessor.php	(working copy)
@@ -253,8 +253,6 @@
          *     RequestDescription::getTopCount will give non-null value.
          *      
          */
-        // @TODO bjoern: Defining default orderby brakes auto sorting option from resource
-        /*
         if (!is_null($this->_requestDescription->getSkipCount())
             || !is_null($this->_requestDescription->getTopCount())
         ) {
@@ -267,7 +265,6 @@
 
             $orderBy = rtrim($orderBy, ', ');
         }
-        
 
         if (!is_null($orderBy)) {
             try {
@@ -285,7 +282,6 @@
                 throw $odataException;
             }
         }
-        */
     }
 
     /**
Index: library/ODataProducer/UriProcessor/UriProcessor.php
===================================================================
--- library/ODataProducer/UriProcessor/UriProcessor.php	(revision 2307)
+++ library/ODataProducer/UriProcessor/UriProcessor.php	(working copy)
@@ -390,13 +390,13 @@
             if (!empty($result)) {
                 $top  = $this->_requestDescription->getTopCount();
                 $skip = $this->_requestDescription->getSkipCount();
-                #if (!is_null($top) && !is_null($skip)) {
-                #    $result = array_slice($result, $skip, $top);
-                #} else if (is_null($top)) {
-                #    $result = array_slice($result, $skip);
-                #} else if (is_null($skip)) {
-                #    $result = array_slice($result, 0, $top);
-                #}
+                if (!is_null($top) && !is_null($skip)) {
+                    $result = array_slice($result, $skip, $top);
+                } else if (is_null($top)) {
+                    $result = array_slice($result, $skip);
+                } else if (is_null($skip)) {
+                    $result = array_slice($result, 0, $top);
+                }
 
                 //$skip and $top affects $count so consider here.
                 if ($this->_requestDescription->getRequestCountOption() == RequestCountOption::VALUE_ONLY) {
Index: library/ODataProducer/Writers/Common/BaseODataWriter.php
===================================================================
--- library/ODataProducer/Writers/Common/BaseODataWriter.php	(revision 2307)
+++ library/ODataProducer/Writers/Common/BaseODataWriter.php	(working copy)
@@ -26,7 +26,6 @@
 use ODataProducer\ObjectModel\ODataBagContent;
 use ODataProducer\ObjectModel\ODataProperty;
 use ODataProducer\ObjectModel\ODataMediaLink;
-use SimpleXMLElement;
 /** 
  * Base class for OData writers.
  * 
@@ -371,31 +370,10 @@
             $this->beginWriteProperty(
                 $odataProperty, $odataPropertyContent->isTopLevel
             );
-            //@TODO We need some smart logic to represent any complex type
-
             if ($odataProperty->value == null) {
                 $this->writeNullValue($odataProperty);
-            } elseif ($odataProperty->value instanceof DOMNode) {
-            	
+            } elseif ($odataProperty->value instanceof ODataPropertyContent) {
                 $this->beginComplexProperty($odataProperty);
-                $xml = str_replace( '<?xml version="1.0" encoding="utf-8"?>'. "\n", '', $odataProperty->value->saveXML());
-                $xml = str_replace( '<?xml version="1.0" encoding="UTF-8"?>'. "\n", '', $xml);
-                $xml = str_replace( '<?xml version="1.0"?>'. "\n", '', $xml);
-                $this->xmlWriter->writeRaw( $xml );
-                #$this->writeBeginProperties($odataProperty->value);
-                $this->endComplexProperty();
-            }elseif ($odataProperty->value instanceof SimpleXMLElement) {
-            	
-                $this->beginComplexProperty($odataProperty);
-
-                $xml = str_replace( '<?xml version="1.0" encoding="utf-8"?>'. "\n", '', $odataProperty->value->saveXML());
-                $xml = str_replace( '<?xml version="1.0" encoding="UTF-8"?>'. "\n", '', $xml);
-                $xml = str_replace( '<?xml version="1.0"?>'. "\n", '', $xml);
-                $this->xmlWriter->writeRaw( $xml );
-                #$this->writeBeginProperties($odataProperty->value);
-                $this->endComplexProperty();
-            }elseif ($odataProperty->value instanceof ODataPropertyContent) {
-                $this->beginComplexProperty($odataProperty);
                 $this->writeBeginProperties($odataProperty->value);
                 $this->endComplexProperty();
             } elseif ($odataProperty->value instanceof ODataBagContent) {
Index: library/ODataProducer/Writers/Json/JsonWriter.php
===================================================================
--- library/ODataProducer/Writers/Json/JsonWriter.php	(revision 2307)
+++ library/ODataProducer/Writers/Json/JsonWriter.php	(working copy)
@@ -1,414 +1,414 @@
-<?php
-/**
- * Provides a writer implementaion for Json format 
- * 
- * PHP version 5.3
- * 
- * @category  ODataProducer
- * @package   ODataProducer_Writers_Json
- * @author    Bibin Kurian <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   SVN: 1.0
- * @link      http://odataphpproducer.codeplex.com
- * 
- */
-namespace ODataProducer\Writers\Json;
-use ODataProducer\Writers\Json\IndentedTextWriter;
-use ODataProducer\Common\ODataConstants;
-/**
- * Json text writer.
- * 
- * @category  ODataProducer
- * @package   ODataProducer_Writers_Json
- * @author    Bibin Kurian <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   Release: 1.0
- * @link      http://odataphpproducer.codeplex.com
- */
-class JsonWriter
-{
-    /**
-     * Json datetime format.
-     *
-     */
-    private $_jsonDateTimeFormat = "\/Date(%s)\/";
-
-    /**
-     * Text used to start a data object wrapper in JSON.
-     *
-     */
-    private $_jsonDataWrapper = "\"d\" : ";
-
-    /**
-     * Writer to write text into
-     *
-     */
-    private $_writer;
-
-    /**
-     * scope of the json text - object, array, etc
-     *
-     */
-    private $_scopes = array();
-
-    /**
-     * Various scope types for Json writer
-     *
-     */
-    private $_scopeType = array('Array' => 0, 'Object' => 1);
-
-    /**
-     * Creates a new instance of Json writer
-     * 
-     * @param string $writer writer to which text needs to be written
-     */
-    public function __construct($writer)
-    {
-        $this->_writer = new IndentedTextWriter($writer);
-    }
-
-    /**
-     * End the current scope
-     * 
-     * @return nothing
-     */
-    public function endScope()
-    {
-        $this->_writer->writeLine();
-        $this->_writer->_indentLevel--;
- 
-        $scope = array_pop($this->_scopes);
-        if ($scope->Type == $this->_scopeType['Array']) {
-            $this->_writer->writeValue("]");
-        } else {
-            $this->_writer->writeValue("}");
-        }
-    }
-
-    /**
-     * Start the array scope
-     * 
-     * @return nothing
-     */
-    public function startArrayScope()
-    {
-        $this->_startScope($this->_scopeType['Array']);
-    }
-
-    /**
-     * Write the "d" wrapper text
-     * 
-     * @return nothing
-     */
-    public function writeDataWrapper()
-    {
-        $this->_writer->writeValue($this->_jsonDataWrapper);
-    }
-
-    /**
-     * Write the "results" header for the data array
-     * 
-     * @return nothing
-     */
-    public function writeDataArrayName()
-    {
-        $this->writeName(ODataConstants::JSON_RESULT_NAME);
-    }
-
-    /**
-     * Start the object scope
-     *
-     * @return nothing
-     */
-    public function startObjectScope()
-    {
-        $this->_startScope($this->_scopeType['Object']);
-    }
-
-    /**
-     * Write the name for the object property
-     * 
-     * @param string $name name of the object property
-     * 
-     * @return nothing
-     */
-    public function writeName($name)
-    {
-        $currentScope = end($this->_scopes);
-        if ($currentScope->Type == $this->_scopeType['Object']) {
-            if ($currentScope->ObjectCount != 0) {
-                $this->_writer->writeTrimmed(", ");
-            }
-
-            $currentScope->ObjectCount++;
-        }
-
-        $this->_writeCore($name, true /*quotes*/);
-        $this->_writer->writeTrimmed(": ");
-    }
-
-    /**
-     * JSON write a basic data type (string, number, boolean, null)
-     * 
-     * @param mixed  $value value to be written
-     * @param string $type  data type of the value
-     * 
-     * @return nothing
-     */
-    public function writeValue($value, $type = null)
-    {
-        switch (true) {
-        case ($type == 'Edm.Boolean'):
-            $this->_writeCore($value, /* quotes */ false);
-            break;
-
-        case ($type == 'Edm.Int16'):
-            $this->_writeCore($value, /* quotes */ false);
-            break;
-                
-        case ($type == 'Edm.Int32'):
-            $this->_writeCore($value, /* quotes */ false);
-            break;
-
-        case ($type == 'Edm.Int64'):
-            $this->_writeCore($value, /* quotes */ true);
-            break;
-
-        case ($type == 'Edm.Single'):
-            if (is_infinite($value) || is_nan($value)) {
-                $this->_writeCore("null", /* quotes */ true);
-            } else {
-                $this->_writeCore($value, /* quotes */ false);
-            }
-
-            break;
-
-        case ($type == 'Edm.Double'):
-            if (is_infinite($value) || is_nan($value)) {
-                $this->_writeCore("null", /* quotes */ true);
-            } else {
-                $this->_writeCore($value, /* quotes */ false);
-            }
-
-            break;
-
-        case ($type == 'Edm.Guid'):
-            $this->_writeCore($value, /* quotes */ true);
-            break;
-
-        case ($type == 'Edm.Decimal'):
-            $this->_writeCore($value, /* quotes */ true);
-            break;
-
-        case ($type == 'Edm.DateTime'):
-            $dateTime = new \DateTime($value, new \DateTimeZone('UTC'));
-            $timeStamp = $dateTime->getTimestamp();
-            $formattedDateTime = sprintf($this->_jsonDateTimeFormat, $timeStamp);
-            $this->_writeCore($formattedDateTime, /* quotes */ true);
-            break;
-
-        case ($type == 'Edm.Byte'):
-            $this->_writeCore($value, /* quotes */ false);
-            break;
-
-        case ($type == 'Edm.SByte'):
-            $this->_writeCore($value, /* quotes */ false);
-            break;
-
-        case ($type == 'Edm.String'):
-            if ($value == null) {
-                $this->_writeCore("null", /* quotes */ false);
-            } else {
-                $jsonEncoded = json_encode($value);
-                //json_encode always escapes a solidus (forward slash, %x2F), 
-                //this will be a problem when encoding urls
-                //JSON_UNESCAPED_SLASHES not available in earlier versions of php 5.3
-                //So removing escaping forward slashes manually
-                $jsonEncoded = str_replace('\\/', '/', $jsonEncoded);
-                //since json_encode is already appending chords 
-                //there is no need to set it again
-                $this->_writeCore($jsonEncoded, /* quotes */ false);
-            }
-            break;
-
-        case ($type == 'Edm.Binary'):
-            $this->_writeCore($value, /* quotes */ true);
-            break;
-
-        default:
-            $this->_writeCore($this->_quoteJScriptString($value), /* quotes */ true);
-        }
-    }
-
-    /**
-     * Returns the string value with special characters escaped
-     * 
-     * @param string $string input string value
-     * 
-     * Returns the string value with special characters escaped.
-     * 
-     * @return string
-     */
-    private function _quoteJScriptString($string)
-    {
-        // Escape ( " \ / \n \r \t \b \f) characters with a backslash.
-        $search  = array('\\', "\n", "\t", "\r", "\b", "\f", '"');
-        $replace = array('\\\\', '\\n', '\\t', '\\r', '\\b', '\\f', '\"');
-        $processedString  = str_replace($search, $replace, $string);
-        // Escape some ASCII characters(0x08, 0x0c)
-        $processedString = str_replace(array(chr(0x08), chr(0x0C)), array('\b', '\f'), $processedString);
-        return $processedString;
-    }
-
-    /**
-     * Write the string value with/without quotes
-     * 
-     * @param string $text   value to be written
-     * @param string $quotes put quotes around the value if this value is true
-     * 
-     * @return nothing
-     */
-    private function _writeCore($text, $quotes)
-    {
-        if (count($this->_scopes) != 0) {
-            $currentScope = end($this->_scopes);
-            if ($currentScope->Type == $this->_scopeType['Array']) {
-                if ($currentScope->ObjectCount != 0) {
-                    $this->_writer->writeTrimmed(", ");
-                }
-
-                $currentScope->ObjectCount++;
-            }
-        }
-
-        if ($quotes) {
-            $this->_writer->writeValue('"');
-        }
-
-        $this->_writer->writeValue($text);
-        if ($quotes) {
-            $this->_writer->writeValue('"');
-        }
-    }
-
-    /**
-     * Start the scope given the scope type
-     * 
-     * @param int $type scope type
-     * 
-     * @return nothing
-     */
-    private function _startScope($type)
-    {
-        if (count($this->_scopes) != 0) {
-            $currentScope = end($this->_scopes);
-            if (($currentScope->Type == $this->_scopeType['Array']) 
-                && ($currentScope->ObjectCount != 0)
-            ) {
-                $this->_writer->writeTrimmed(", ");
-            }
-
-            $currentScope->ObjectCount++;
-        }
-
-        $scope = new Scope($type);
-        array_push($this->_scopes, $scope);
-
-        if ($type == $this->_scopeType['Array']) {
-            $this->_writer->writeValue("[");
-        } else {
-            $this->_writer->writeValue("{");
-        }
-
-        $this->_writer->_indentLevel++;
-        $this->_writer->writeLine();
-    }
-
-    /**
-     * return the intented result
-     * 
-     * @return string
-     */
-    public function getJsonOutput()
-    {
-        return $this->_writer->_result;
-    }
-}
-
-/**
- * class representing scope information 
- * 
- * @category  ODataProducer
- * @package   ODataProducer_Writers_Json
- * @author    Bibin Kurian <odataphpproducer_alias@microsoft.com>
- * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
- * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
- * @version   Release: 1.0
- * @link      http://odataphpproducer.codeplex.com
- */
-class Scope
-{
-    /**
-     * keeps the count of the nested scopes
-     *      
-     */
-    private $_objectCount;
-
-    /**
-     *  keeps the type of the scope
-     *      
-     */
-    private $_type;
-
-    /**
-     * Creates a new instance of scope type
-     * 
-     * @param int $type type of the scope
-     */
-    public function __construct($type)
-    {
-        $this->_type = $type;
-    }
-
-    /**
-     * setter for scope
-     * 
-     * @param string $name  name of the varriable to be set
-     * @param int    $value value of the varriable
-     * 
-     * @return nothing
-     */
-    public function __set($name, $value)
-    {
-        switch ($name) {
-        case 'ObjectCount':
-            $this->_objectCount = $value;
-            break;
-        case 'Type':
-            $this->_type = $value;
-            break;
-        }
-    }
-
-    /**
-     * getter for scope
-     * 
-     * @param string $name name of the varriable to be get
-     * 
-     * @return int
-     */
-    public function __get($name)
-    {
-        switch ($name) {
-        case 'ObjectCount':
-            return $this->_objectCount;
-            break;
-        case 'Type':
-            return $this->_type;
-            break;
-        }
-    }
-}
+<?php
+/**
+ * Provides a writer implementaion for Json format 
+ * 
+ * PHP version 5.3
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_Writers_Json
+ * @author    Bibin Kurian <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   SVN: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ * 
+ */
+namespace ODataProducer\Writers\Json;
+use ODataProducer\Writers\Json\IndentedTextWriter;
+use ODataProducer\Common\ODataConstants;
+/**
+ * Json text writer.
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_Writers_Json
+ * @author    Bibin Kurian <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   Release: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ */
+class JsonWriter
+{
+    /**
+     * Json datetime format.
+     *
+     */
+    private $_jsonDateTimeFormat = "\/Date(%s)\/";
+
+    /**
+     * Text used to start a data object wrapper in JSON.
+     *
+     */
+    private $_jsonDataWrapper = "\"d\" : ";
+
+    /**
+     * Writer to write text into
+     *
+     */
+    private $_writer;
+
+    /**
+     * scope of the json text - object, array, etc
+     *
+     */
+    private $_scopes = array();
+
+    /**
+     * Various scope types for Json writer
+     *
+     */
+    private $_scopeType = array('Array' => 0, 'Object' => 1);
+
+    /**
+     * Creates a new instance of Json writer
+     * 
+     * @param string $writer writer to which text needs to be written
+     */
+    public function __construct($writer)
+    {
+        $this->_writer = new IndentedTextWriter($writer);
+    }
+
+    /**
+     * End the current scope
+     * 
+     * @return nothing
+     */
+    public function endScope()
+    {
+        $this->_writer->writeLine();
+        $this->_writer->_indentLevel--;
+ 
+        $scope = array_pop($this->_scopes);
+        if ($scope->Type == $this->_scopeType['Array']) {
+            $this->_writer->writeValue("]");
+        } else {
+            $this->_writer->writeValue("}");
+        }
+    }
+
+    /**
+     * Start the array scope
+     * 
+     * @return nothing
+     */
+    public function startArrayScope()
+    {
+        $this->_startScope($this->_scopeType['Array']);
+    }
+
+    /**
+     * Write the "d" wrapper text
+     * 
+     * @return nothing
+     */
+    public function writeDataWrapper()
+    {
+        $this->_writer->writeValue($this->_jsonDataWrapper);
+    }
+
+    /**
+     * Write the "results" header for the data array
+     * 
+     * @return nothing
+     */
+    public function writeDataArrayName()
+    {
+        $this->writeName(ODataConstants::JSON_RESULT_NAME);
+    }
+
+    /**
+     * Start the object scope
+     *
+     * @return nothing
+     */
+    public function startObjectScope()
+    {
+        $this->_startScope($this->_scopeType['Object']);
+    }
+
+    /**
+     * Write the name for the object property
+     * 
+     * @param string $name name of the object property
+     * 
+     * @return nothing
+     */
+    public function writeName($name)
+    {
+        $currentScope = end($this->_scopes);
+        if ($currentScope->Type == $this->_scopeType['Object']) {
+            if ($currentScope->ObjectCount != 0) {
+                $this->_writer->writeTrimmed(", ");
+            }
+
+            $currentScope->ObjectCount++;
+        }
+
+        $this->_writeCore($name, true /*quotes*/);
+        $this->_writer->writeTrimmed(": ");
+    }
+
+    /**
+     * JSON write a basic data type (string, number, boolean, null)
+     * 
+     * @param mixed  $value value to be written
+     * @param string $type  data type of the value
+     * 
+     * @return nothing
+     */
+    public function writeValue($value, $type = null)
+    {
+        switch (true) {
+        case ($type == 'Edm.Boolean'):
+            $this->_writeCore($value, /* quotes */ false);
+            break;
+
+        case ($type == 'Edm.Int16'):
+            $this->_writeCore($value, /* quotes */ false);
+            break;
+                
+        case ($type == 'Edm.Int32'):
+            $this->_writeCore($value, /* quotes */ false);
+            break;
+
+        case ($type == 'Edm.Int64'):
+            $this->_writeCore($value, /* quotes */ true);
+            break;
+
+        case ($type == 'Edm.Single'):
+            if (is_infinite($value) || is_nan($value)) {
+                $this->_writeCore("null", /* quotes */ true);
+            } else {
+                $this->_writeCore($value, /* quotes */ false);
+            }
+
+            break;
+
+        case ($type == 'Edm.Double'):
+            if (is_infinite($value) || is_nan($value)) {
+                $this->_writeCore("null", /* quotes */ true);
+            } else {
+                $this->_writeCore($value, /* quotes */ false);
+            }
+
+            break;
+
+        case ($type == 'Edm.Guid'):
+            $this->_writeCore($value, /* quotes */ true);
+            break;
+
+        case ($type == 'Edm.Decimal'):
+            $this->_writeCore($value, /* quotes */ true);
+            break;
+
+        case ($type == 'Edm.DateTime'):
+            $dateTime = new \DateTime($value, new \DateTimeZone('UTC'));
+            $timeStamp = $dateTime->getTimestamp();
+            $formattedDateTime = sprintf($this->_jsonDateTimeFormat, $timeStamp);
+            $this->_writeCore($formattedDateTime, /* quotes */ true);
+            break;
+
+        case ($type == 'Edm.Byte'):
+            $this->_writeCore($value, /* quotes */ false);
+            break;
+
+        case ($type == 'Edm.SByte'):
+            $this->_writeCore($value, /* quotes */ false);
+            break;
+
+        case ($type == 'Edm.String'):
+            if ($value == null) {
+                $this->_writeCore("null", /* quotes */ false);
+            } else {
+                $jsonEncoded = json_encode($value);
+                //json_encode always escapes a solidus (forward slash, %x2F), 
+                //this will be a problem when encoding urls
+                //JSON_UNESCAPED_SLASHES not available in earlier versions of php 5.3
+                //So removing escaping forward slashes manually
+                $jsonEncoded = str_replace('\\/', '/', $jsonEncoded);
+                //since json_encode is already appending chords 
+                //there is no need to set it again
+                $this->_writeCore($jsonEncoded, /* quotes */ false);
+            }
+            break;
+
+        case ($type == 'Edm.Binary'):
+            $this->_writeCore($value, /* quotes */ true);
+            break;
+
+        default:
+            $this->_writeCore($this->_quoteJScriptString($value), /* quotes */ true);
+        }
+    }
+
+    /**
+     * Returns the string value with special characters escaped
+     * 
+     * @param string $string input string value
+     * 
+     * Returns the string value with special characters escaped.
+     * 
+     * @return string
+     */
+    private function _quoteJScriptString($string)
+    {
+        // Escape ( " \ / \n \r \t \b \f) characters with a backslash.
+        $search  = array('\\', "\n", "\t", "\r", "\b", "\f", '"');
+        $replace = array('\\\\', '\\n', '\\t', '\\r', '\\b', '\\f', '\"');
+        $processedString  = str_replace($search, $replace, $string);
+        // Escape some ASCII characters(0x08, 0x0c)
+        $processedString = str_replace(array(chr(0x08), chr(0x0C)), array('\b', '\f'), $processedString);
+        return $processedString;
+    }
+
+    /**
+     * Write the string value with/without quotes
+     * 
+     * @param string $text   value to be written
+     * @param string $quotes put quotes around the value if this value is true
+     * 
+     * @return nothing
+     */
+    private function _writeCore($text, $quotes)
+    {
+        if (count($this->_scopes) != 0) {
+            $currentScope = end($this->_scopes);
+            if ($currentScope->Type == $this->_scopeType['Array']) {
+                if ($currentScope->ObjectCount != 0) {
+                    $this->_writer->writeTrimmed(", ");
+                }
+
+                $currentScope->ObjectCount++;
+            }
+        }
+
+        if ($quotes) {
+            $this->_writer->writeValue('"');
+        }
+
+        $this->_writer->writeValue($text);
+        if ($quotes) {
+            $this->_writer->writeValue('"');
+        }
+    }
+
+    /**
+     * Start the scope given the scope type
+     * 
+     * @param int $type scope type
+     * 
+     * @return nothing
+     */
+    private function _startScope($type)
+    {
+        if (count($this->_scopes) != 0) {
+            $currentScope = end($this->_scopes);
+            if (($currentScope->Type == $this->_scopeType['Array']) 
+                && ($currentScope->ObjectCount != 0)
+            ) {
+                $this->_writer->writeTrimmed(", ");
+            }
+
+            $currentScope->ObjectCount++;
+        }
+
+        $scope = new Scope($type);
+        array_push($this->_scopes, $scope);
+
+        if ($type == $this->_scopeType['Array']) {
+            $this->_writer->writeValue("[");
+        } else {
+            $this->_writer->writeValue("{");
+        }
+
+        $this->_writer->_indentLevel++;
+        $this->_writer->writeLine();
+    }
+
+    /**
+     * return the intented result
+     * 
+     * @return string
+     */
+    public function getJsonOutput()
+    {
+        return $this->_writer->_result;
+    }
+}
+
+/**
+ * class representing scope information 
+ * 
+ * @category  ODataProducer
+ * @package   ODataProducer_Writers_Json
+ * @author    Bibin Kurian <odataphpproducer_alias@microsoft.com>
+ * @copyright 2011 Microsoft Corp. (http://www.microsoft.com)
+ * @license   New BSD license, (http://www.opensource.org/licenses/bsd-license.php)
+ * @version   Release: 1.0
+ * @link      http://odataphpproducer.codeplex.com
+ */
+class Scope
+{
+    /**
+     * keeps the count of the nested scopes
+     *      
+     */
+    private $_objectCount;
+
+    /**
+     *  keeps the type of the scope
+     *      
+     */
+    private $_type;
+
+    /**
+     * Creates a new instance of scope type
+     * 
+     * @param int $type type of the scope
+     */
+    public function __construct($type)
+    {
+        $this->_type = $type;
+    }
+
+    /**
+     * setter for scope
+     * 
+     * @param string $name  name of the varriable to be set
+     * @param int    $value value of the varriable
+     * 
+     * @return nothing
+     */
+    public function __set($name, $value)
+    {
+        switch ($name) {
+        case 'ObjectCount':
+            $this->_objectCount = $value;
+            break;
+        case 'Type':
+            $this->_type = $value;
+            break;
+        }
+    }
+
+    /**
+     * getter for scope
+     * 
+     * @param string $name name of the varriable to be get
+     * 
+     * @return int
+     */
+    public function __get($name)
+    {
+        switch ($name) {
+        case 'ObjectCount':
+            return $this->_objectCount;
+            break;
+        case 'Type':
+            return $this->_type;
+            break;
+        }
+    }
+}
 ?>
\ No newline at end of file
Index: library/ODataProducer/Writers/Metadata/MetadataAssociationTypeSet.php
===================================================================
--- library/ODataProducer/Writers/Metadata/MetadataAssociationTypeSet.php	(revision 2307)
+++ library/ODataProducer/Writers/Metadata/MetadataAssociationTypeSet.php	(working copy)
@@ -33,7 +33,7 @@
 use ODataProducer\Providers\Metadata\ResourceType;
 use ODataProducer\Providers\Metadata\ResourceProperty;
 use ODataProducer\Providers\Metadata\ResourceSetWrapper;
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Writers'.DIRECTORY_SEPARATOR.'Metadata'.DIRECTORY_SEPARATOR.'MetadataBase.php';
+require_once 'ODataProducer\Writers\Metadata\MetadataBase.php';
 /** 
  * This class validates all AssociationSet defined for the service and creates
  * AssociationType for each AssociationSet from the given provider.
Index: services/NorthWind/NorthWindDataService.php
===================================================================
--- services/NorthWind/NorthWindDataService.php	(revision 2307)
+++ services/NorthWind/NorthWindDataService.php	(working copy)
@@ -14,10 +14,10 @@
  * 
  */
 use ODataProducer\Configuration\EntitySetRights;
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'IDataService.php';
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'IRequestHandler.php';
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'DataService.php';
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'IServiceProvider.php';
+require_once 'ODataProducer\IDataService.php';
+require_once 'ODataProducer\IRequestHandler.php';
+require_once 'ODataProducer\DataService.php';
+require_once 'ODataProducer\IServiceProvider.php';
 use ODataProducer\Configuration\DataServiceProtocolVersion;
 use ODataProducer\Configuration\DataServiceConfiguration;
 use ODataProducer\IServiceProvider;
Index: services/NorthWind/NorthWindMetadata.php
===================================================================
--- services/NorthWind/NorthWindMetadata.php	(revision 2307)
+++ services/NorthWind/NorthWindMetadata.php	(working copy)
@@ -25,7 +25,7 @@
 use ODataProducer\Providers\Metadata\ResourceType;
 use ODataProducer\Common\InvalidOperationException;
 use ODataProducer\Providers\Metadata\IDataServiceMetadataProvider;
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Metadata'.DIRECTORY_SEPARATOR.'IDataServiceMetadataProvider.php';
+require_once 'ODataProducer\Providers\Metadata\IDataServiceMetadataProvider.php';
 use ODataProducer\Providers\Metadata\ServiceBaseMetadata;
 //Begin Resource Classes
 
Index: services/NorthWind/NorthWindQueryProvider.php
===================================================================
--- services/NorthWind/NorthWindQueryProvider.php	(revision 2307)
+++ services/NorthWind/NorthWindQueryProvider.php	(working copy)
@@ -18,7 +18,7 @@
 use ODataProducer\Providers\Metadata\ResourceProperty;
 use ODataProducer\Providers\Query\IDataServiceQueryProvider;
 require_once "NorthWindMetadata.php";
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Query'.DIRECTORY_SEPARATOR.'IDataServiceQueryProvider.php';
+require_once "ODataProducer\Providers\Query\IDataServiceQueryProvider.php";
 define('DATABASE', 'Northwind');
 define('SERVER', '.\sqlexpress');
 
Index: services/NorthWind/NorthWindStreamProvider.php
===================================================================
--- services/NorthWind/NorthWindStreamProvider.php	(revision 2307)
+++ services/NorthWind/NorthWindStreamProvider.php	(working copy)
@@ -13,11 +13,11 @@
  * @link      http://odataphpproducer.codeplex.com
  * 
  */
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Stream'.DIRECTORY_SEPARATOR.'IDataServiceStreamProvider2.php';
+require_once 'ODataProducer\Providers\Stream\IDataServiceStreamProvider2.php';
 /**
  * Stream provider for northwind service.
  */
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Common'.DIRECTORY_SEPARATOR.'ODataException.php';
+require_once 'ODataProducer\Common\ODataException.php';
 require_once 'NorthWindMetadata.php';
 use ODataProducer\Providers\Metadata\ResourceStreamInfo;
 use ODataProducer\Providers\Stream\IDataServiceStreamProvider2;
Index: services/WordPress/WordPressDataService.php
===================================================================
--- services/WordPress/WordPressDataService.php	(revision 2307)
+++ services/WordPress/WordPressDataService.php	(working copy)
@@ -14,10 +14,10 @@
  * 
  */
 use ODataProducer\Configuration\EntitySetRights;
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'IDataService.php';
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'IRequestHandler.php';
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'DataService.php';
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'IServiceProvider.php';
+require_once 'ODataProducer\IDataService.php';
+require_once 'ODataProducer\IRequestHandler.php';
+require_once 'ODataProducer\DataService.php';
+require_once 'ODataProducer\IServiceProvider.php';
 use ODataProducer\Configuration\DataServiceProtocolVersion;
 use ODataProducer\Configuration\DataServiceConfiguration;
 use ODataProducer\IServiceProvider;
Index: services/WordPress/WordPressMetadata.php
===================================================================
--- services/WordPress/WordPressMetadata.php	(revision 2307)
+++ services/WordPress/WordPressMetadata.php	(working copy)
@@ -25,7 +25,7 @@
 use ODataProducer\Providers\Metadata\ResourceType;
 use ODataProducer\Common\InvalidOperationException;
 use ODataProducer\Providers\Metadata\IDataServiceMetadataProvider;
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Metadata'.DIRECTORY_SEPARATOR.'IDataServiceMetadataProvider.php';
+require_once 'ODataProducer\Providers\Metadata\IDataServiceMetadataProvider.php';
 use ODataProducer\Providers\Metadata\ServiceBaseMetadata;
 
 //Begin Resource Classes
Index: services/WordPress/WordPressQueryProvider.php
===================================================================
--- services/WordPress/WordPressQueryProvider.php	(revision 2307)
+++ services/WordPress/WordPressQueryProvider.php	(working copy)
@@ -18,7 +18,7 @@
 use ODataProducer\Providers\Metadata\ResourceProperty;
 use ODataProducer\Providers\Query\IDataServiceQueryProvider;
 require_once "WordPressMetadata.php";
-require_once 'ODataProducer'.DIRECTORY_SEPARATOR.'Providers'.DIRECTORY_SEPARATOR.'Query'.DIRECTORY_SEPARATOR.'IDataServiceQueryProvider.php';
+require_once "ODataProducer\Providers\Query\IDataServiceQueryProvider.php";
 /** The name of the database for WordPress */
 define('DB_NAME', 'wordpress');
 
